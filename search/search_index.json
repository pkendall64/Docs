{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"faq/","text":"Below, we have a list of frequently asked questions about ELRS Why ExpressLRS? \u00b6 ExpressLRS is competing with some of the best commercial solutions out there, but all are expensive \ud83d\ude41. Well, ELRS is not \ud83d\ude04, it can be set up for around 60$ (Using second-hand r9 hardware). It also is better than many (higher sensitivity, lower latency\ud83d\udc4c). Is it better than the commercial solutions? \u00b6 It is faster than most links out there with a latency of 6.5ms (at 200hz). At 250hz 100mW 2.4GHz it is capable of ranges 30km+. Which OpenTX version works with ExpressLRS \u00b6 OpenTX 2.3.12 or newer should work just fine. No need to use OpenTX Nightly, unless you have requirements not present in the Stable versions. EdgeTX 2.4.0 or newer should work too. Why do I need to update OpenTX? \u00b6 ExpressLRS needs your radio to support crsfshot (a.k.a. Mixersync) to work properly. This will give you the lowest possible latency and optimal consistency of the RC link. When your radio does not have crsfshot working, this often shows in your ExpressLRS Lua script. The Lua script top bar will show inconsistent numbers like 0:63 or is stuck at 0:250 at every packet rate rate you select. The Lua script top bar should always show a stable 0:[user selected packet rate] For example: 0:50, 0:150, 0:250, 0:500, ... When that is the case your radio has crsfshot working and you're good to go. Click here to read more on OpenTX. How can I flash/update x receiver/module? \u00b6 See Getting Started page Will x Receiver work with y TX Module from z Manufacturer? \u00b6 Any Receiver and TX Module from the same Band (2.4GHz or 900Mhz) will work together. Supported R9 receivers will work with the 900Mhz modules from Happy Model, Namimno RC and the R9M, same with the other 900Mhz receivers, DIY or off-the-shelf. Likewise, any 2.4Ghz receivers should work with any 2.4Ghz TX Modules, from any manufacturer and even the DIY ones. This is as long as they have the same binding phrase and configuration options (Regulatory Domain, Performance Options and Extra Data). What's the difference between the different Happymodel 2.4GHz receivers (PP, EP1, EP2)? \u00b6 The difference between the PP and the EP1/EP2 is only the processor. The PP is the original design and uses an STM32 while the EP1/EP2 use an ESP82xx. Both offer firmware update through Betaflight passthrough, but the EPx also support firmware upload over wifi. The EP1 is the same as the EP2 except it has a U.FL/IPEX1 connector for an external antenna. The wifi capability of the ESP is not used apart from the update procedure, and the wifi is only enabled shortly after power-up if no TX connection is received ( AUTO_WIFI_ON_INTERVAL if bound, 60s otherwise). Receiver performance should be identical between the two. If you're confused by the PP being more expensive, it's because there is a shortage of the STM part. What is required to achieve a 500hz update rate on 2.4ghz on OpenTX? \u00b6 Make sure to enable the \"Use_500hz\" option when you flash the TX and RX. You must also be on a version of OpenTX that supports Mixer Sync (TBS Nightly, ELRS Nightly, OpenTX 2.3.12 or newer, or EdgeTX). USE_500Hz option is now enabled be default starting with 1.0.0-RC9 (6358aa). To confirm your update rate is working as intended, you can use the ExpressLRS Lua script to check the current update rate and confirm you are getting 500hz. How many channels does ELRS support? \u00b6 12 channels(suspicious asterisk). There is not enough bandwidth to support all full-resolution channels (e.g. for pan/tilt servos). It is possible that future versions could include some tricks to expand this by sending extra channel data in a slow upload, but it is not a priority for development. Therefore, ELRS provides: * 4x full-resolution (10-bit) channels for sticks (CH1-4) * Either: * Standard Mode 4x 2-position channels sent every frame (increased to 8x in 1.0), OR * HYBRID_SWITCHES_8 Mode 8x 3-position channels, where CH5 (AUX1/ARM) is sent every frame, and the other 7 are sent round-robin (7 frames to send all channels) also changed in 1.0, see Switch Modes Is my binding phrase a secret? \u00b6 No, just like what channel your VTX is on is not a secret. The binding phrase is not security, it is anti-collision. If everyone kept their VTX channel a secret, the chances of you blasting someone out of the sky accidentally is pretty high. To provide the best chance of not interfering with other pilots and them not interfering with you, be sure you're not using the same dumb bind phrase as someone else. Express your style with a hilarious or saucy bind phrase. What does RQLY, TQLY, RSSI x2, SNR x2 mean? \u00b6 Datapoint Description Range Info RQly Uplink - link quality (valid packets) 0 - 100 The number of successful packets out of the last 100 from TX \u2192 RX 1RSS Uplink - received signal strength antenna 1 (RSSI) -128 - 0 RSSI dBm as reported by the RX. Values vary depending on mode, antenna quality, output power and distance 2RSS Uplink - received signal strength antenna 2 (RSSI) Second antenna RSSI, used in diversity mode ANT RX active Antenna Not populated currently RSNR Uplink - signal-to-noise ratio SNR reported by the RX. Value varies mostly by radio chip and gets lower with distance (once the agc hits its limit) RFMD Uplink - update rate TPWR Uplink - transmitting power 50mW reported as 0, as CRSF/OpenTX do not have this option TQly Downlink - link quality (valid packets) 0 - 100 An LQ indicator of telemetry packets received RX \u2192 TX TRSS Downlink - received signal strength (RSSI) RSSI dBm of telemetry packets received by TX TSNR Downlink - signal-to-noise ratio SNR reported by the radio in the TX module when receiving telemetry packets Is it normal to get \"RF Signal Critical\" when plugging in? \u00b6 Yes. When the connection is first established, the link quality starts at 0 and climbs as packets are received. Expect low RF Signal warnings until enough packets are reported received to pass your warning threshold set in OpenTX -> Telemetry -> RSSI -> Low alarm / Critical alarm.","title":"FAQ"},{"location":"faq/#why-expresslrs","text":"ExpressLRS is competing with some of the best commercial solutions out there, but all are expensive \ud83d\ude41. Well, ELRS is not \ud83d\ude04, it can be set up for around 60$ (Using second-hand r9 hardware). It also is better than many (higher sensitivity, lower latency\ud83d\udc4c).","title":"Why ExpressLRS?"},{"location":"faq/#is-it-better-than-the-commercial-solutions","text":"It is faster than most links out there with a latency of 6.5ms (at 200hz). At 250hz 100mW 2.4GHz it is capable of ranges 30km+.","title":"Is it better than the commercial solutions?"},{"location":"faq/#which-opentx-version-works-with-expresslrs","text":"OpenTX 2.3.12 or newer should work just fine. No need to use OpenTX Nightly, unless you have requirements not present in the Stable versions. EdgeTX 2.4.0 or newer should work too.","title":"Which OpenTX version works with ExpressLRS"},{"location":"faq/#why-do-i-need-to-update-opentx","text":"ExpressLRS needs your radio to support crsfshot (a.k.a. Mixersync) to work properly. This will give you the lowest possible latency and optimal consistency of the RC link. When your radio does not have crsfshot working, this often shows in your ExpressLRS Lua script. The Lua script top bar will show inconsistent numbers like 0:63 or is stuck at 0:250 at every packet rate rate you select. The Lua script top bar should always show a stable 0:[user selected packet rate] For example: 0:50, 0:150, 0:250, 0:500, ... When that is the case your radio has crsfshot working and you're good to go. Click here to read more on OpenTX.","title":"Why do I need to update OpenTX?"},{"location":"faq/#how-can-i-flashupdate-x-receivermodule","text":"See Getting Started page","title":"How can I flash/update x receiver/module?"},{"location":"faq/#will-x-receiver-work-with-y-tx-module-from-z-manufacturer","text":"Any Receiver and TX Module from the same Band (2.4GHz or 900Mhz) will work together. Supported R9 receivers will work with the 900Mhz modules from Happy Model, Namimno RC and the R9M, same with the other 900Mhz receivers, DIY or off-the-shelf. Likewise, any 2.4Ghz receivers should work with any 2.4Ghz TX Modules, from any manufacturer and even the DIY ones. This is as long as they have the same binding phrase and configuration options (Regulatory Domain, Performance Options and Extra Data).","title":"Will x Receiver work with y TX Module from z Manufacturer?"},{"location":"faq/#whats-the-difference-between-the-different-happymodel-24ghz-receivers-pp-ep1-ep2","text":"The difference between the PP and the EP1/EP2 is only the processor. The PP is the original design and uses an STM32 while the EP1/EP2 use an ESP82xx. Both offer firmware update through Betaflight passthrough, but the EPx also support firmware upload over wifi. The EP1 is the same as the EP2 except it has a U.FL/IPEX1 connector for an external antenna. The wifi capability of the ESP is not used apart from the update procedure, and the wifi is only enabled shortly after power-up if no TX connection is received ( AUTO_WIFI_ON_INTERVAL if bound, 60s otherwise). Receiver performance should be identical between the two. If you're confused by the PP being more expensive, it's because there is a shortage of the STM part.","title":"What's the difference between the different Happymodel 2.4GHz receivers (PP, EP1, EP2)?"},{"location":"faq/#what-is-required-to-achieve-a-500hz-update-rate-on-24ghz-on-opentx","text":"Make sure to enable the \"Use_500hz\" option when you flash the TX and RX. You must also be on a version of OpenTX that supports Mixer Sync (TBS Nightly, ELRS Nightly, OpenTX 2.3.12 or newer, or EdgeTX). USE_500Hz option is now enabled be default starting with 1.0.0-RC9 (6358aa). To confirm your update rate is working as intended, you can use the ExpressLRS Lua script to check the current update rate and confirm you are getting 500hz.","title":"What is required to achieve a 500hz update rate on 2.4ghz on OpenTX?"},{"location":"faq/#how-many-channels-does-elrs-support","text":"12 channels(suspicious asterisk). There is not enough bandwidth to support all full-resolution channels (e.g. for pan/tilt servos). It is possible that future versions could include some tricks to expand this by sending extra channel data in a slow upload, but it is not a priority for development. Therefore, ELRS provides: * 4x full-resolution (10-bit) channels for sticks (CH1-4) * Either: * Standard Mode 4x 2-position channels sent every frame (increased to 8x in 1.0), OR * HYBRID_SWITCHES_8 Mode 8x 3-position channels, where CH5 (AUX1/ARM) is sent every frame, and the other 7 are sent round-robin (7 frames to send all channels) also changed in 1.0, see Switch Modes","title":"How many channels does ELRS support?"},{"location":"faq/#is-my-binding-phrase-a-secret","text":"No, just like what channel your VTX is on is not a secret. The binding phrase is not security, it is anti-collision. If everyone kept their VTX channel a secret, the chances of you blasting someone out of the sky accidentally is pretty high. To provide the best chance of not interfering with other pilots and them not interfering with you, be sure you're not using the same dumb bind phrase as someone else. Express your style with a hilarious or saucy bind phrase.","title":"Is my binding phrase a secret?"},{"location":"faq/#what-does-rqly-tqly-rssi-x2-snr-x2-mean","text":"Datapoint Description Range Info RQly Uplink - link quality (valid packets) 0 - 100 The number of successful packets out of the last 100 from TX \u2192 RX 1RSS Uplink - received signal strength antenna 1 (RSSI) -128 - 0 RSSI dBm as reported by the RX. Values vary depending on mode, antenna quality, output power and distance 2RSS Uplink - received signal strength antenna 2 (RSSI) Second antenna RSSI, used in diversity mode ANT RX active Antenna Not populated currently RSNR Uplink - signal-to-noise ratio SNR reported by the RX. Value varies mostly by radio chip and gets lower with distance (once the agc hits its limit) RFMD Uplink - update rate TPWR Uplink - transmitting power 50mW reported as 0, as CRSF/OpenTX do not have this option TQly Downlink - link quality (valid packets) 0 - 100 An LQ indicator of telemetry packets received RX \u2192 TX TRSS Downlink - received signal strength (RSSI) RSSI dBm of telemetry packets received by TX TSNR Downlink - signal-to-noise ratio SNR reported by the radio in the TX module when receiving telemetry packets","title":"What does RQLY, TQLY, RSSI x2, SNR x2 mean?"},{"location":"faq/#is-it-normal-to-get-rf-signal-critical-when-plugging-in","text":"Yes. When the connection is first established, the link quality starts at 0 and climbs as packets are received. Expect low RF Signal warnings until enough packets are reported received to pass your warning threshold set in OpenTX -> Telemetry -> RSSI -> Low alarm / Critical alarm.","title":"Is it normal to get \"RF Signal Critical\" when plugging in?"},{"location":"license/","text":"License \u00b6 MIT License Copyright \u00a9 2016-2021 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright \u00a9 2016-2021 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"hardware/diy-rx/","text":"Possibly one of the biggest benefits from using ExpressLRS is custom hardware! \ud83d\udcf6 Custom ESP 2.4 GHz RX \ud83d\udce1 Custom ESP 900 MHz RX \u26a1 Flashing ESP Based RX Custom ESP 2.4 GHz RX \u00b6 20x20 footprint and uses 0805 size SMD components. SMD components have been positioned on the PCB in a soldering iron friendly way. \ud83d\udeb8 The ELRS Nano RX is 18mm x 11mm and uses the same pinout as the Crossfire Nano RX. This allows for direct mounting to compatible flight controllers. \u26a0\ufe0f This PCB uses 0402 SMD components and will require a hot air rework station and probably a microscope. \ud83d\udd2c Custom ESP 900 MHz RX \u00b6 Uses the ESP-01F for WiFi and a RFM95 for our business \ud83d\udd74\ufe0f Requires ordering PCBs from Gerber files, a regulator chip, a few passives, a ESP-01F and a RFM95 (915/868MHz) Multiple RX PCB designs are available \u2705 20x20 RX - discrete SMD antenna for Wifi and RF directly soldered to PCB Target DIY_900_RX_ESP8285_SX127x_via_UART 20x20 RX 0805 - easier to build due to bigger SMD parts. PCB antenna for Wifi and u.fl connector for RF Mini RX - the smallest form factor, lightest weight and lowest cost per PCB If you need help soldering, please check out this video Flashing Custom RX \u00b6 Before you start \u00b6 The steps for building are in each individual README.md for the RX of your choice If you are using an ESP-12F instead of ESP-01F it is recommended to follow this tutorial but using the appropriate RX target \ud83e\uddd1\u200d\ud83c\udfeb Get it flashed \u00b6 Connect the serial adapter to GND , TX , RX , and the appropriate 3V3 or 5V . Additionally, connect IO0 to GND to activate the bootloader and enable flashing Quite some serial adapters have TX and RX swapped, mislabeled, or both \ud83d\ude38. Please double-check! Finally, select the appropriate RX target, make sure your user defines are correct, and press Upload in platformio","title":"DIY Receiver"},{"location":"hardware/diy-rx/#custom-esp-24-ghz-rx","text":"20x20 footprint and uses 0805 size SMD components. SMD components have been positioned on the PCB in a soldering iron friendly way. \ud83d\udeb8 The ELRS Nano RX is 18mm x 11mm and uses the same pinout as the Crossfire Nano RX. This allows for direct mounting to compatible flight controllers. \u26a0\ufe0f This PCB uses 0402 SMD components and will require a hot air rework station and probably a microscope. \ud83d\udd2c","title":"Custom ESP 2.4 GHz RX"},{"location":"hardware/diy-rx/#custom-esp-900-mhz-rx","text":"Uses the ESP-01F for WiFi and a RFM95 for our business \ud83d\udd74\ufe0f Requires ordering PCBs from Gerber files, a regulator chip, a few passives, a ESP-01F and a RFM95 (915/868MHz) Multiple RX PCB designs are available \u2705 20x20 RX - discrete SMD antenna for Wifi and RF directly soldered to PCB Target DIY_900_RX_ESP8285_SX127x_via_UART 20x20 RX 0805 - easier to build due to bigger SMD parts. PCB antenna for Wifi and u.fl connector for RF Mini RX - the smallest form factor, lightest weight and lowest cost per PCB If you need help soldering, please check out this video","title":"Custom ESP 900 MHz RX"},{"location":"hardware/diy-rx/#flashing-custom-rx","text":"","title":"Flashing Custom RX"},{"location":"hardware/diy-rx/#before-you-start","text":"The steps for building are in each individual README.md for the RX of your choice If you are using an ESP-12F instead of ESP-01F it is recommended to follow this tutorial but using the appropriate RX target \ud83e\uddd1\u200d\ud83c\udfeb","title":"Before you start"},{"location":"hardware/diy-rx/#get-it-flashed","text":"Connect the serial adapter to GND , TX , RX , and the appropriate 3V3 or 5V . Additionally, connect IO0 to GND to activate the bootloader and enable flashing Quite some serial adapters have TX and RX swapped, mislabeled, or both \ud83d\ude38. Please double-check! Finally, select the appropriate RX target, make sure your user defines are correct, and press Upload in platformio","title":"Get it flashed"},{"location":"hardware/diy-tx/","text":"Custom ESP 2.4 GHz TX (for JR module bay) \u00b6 All of the info on this topic can be found \ud83d\udc49 Here Custom Super Slim ESP 2.4 GHz TX (for lite module bay) \u00b6 The super slim is an evolution of the slim. It uses the same base hardware as the JR size one. It's the same size as an R9M Lite, and fits in all handsets with a lite module bay such as the X-Lite, X9 Lite, and Tango 2 (with the proper adapter). The rest of the info can be found \ud83d\udc49 Here","title":"DIY Transmitter"},{"location":"hardware/diy-tx/#custom-esp-24-ghz-tx-for-jr-module-bay","text":"All of the info on this topic can be found \ud83d\udc49 Here","title":"Custom ESP 2.4 GHz TX (for JR module bay)"},{"location":"hardware/diy-tx/#custom-super-slim-esp-24-ghz-tx-for-lite-module-bay","text":"The super slim is an evolution of the slim. It uses the same base hardware as the JR size one. It's the same size as an R9M Lite, and fits in all handsets with a lite module bay such as the X-Lite, X9 Lite, and Tango 2 (with the proper adapter). The rest of the info can be found \ud83d\udc49 Here","title":"Custom Super Slim ESP 2.4 GHz TX (for lite module bay)"},{"location":"hardware/esp-backpack/","text":"Addon for R9M modules , HappyModel ELRS915TX , and HappyModel ES24TX to allow: Logging to Browser and via Websocket Flashing ESP Backpack (self) Flashing R9M TX Possibly more.. wireless trainer mode? Please contribute \ud83e\udd47 This is a convenience feature for development purposes and \"power users\" - soldering can be tricky - please be careful. \ud83d\udc6e Parts \u00b6 USB to Serial Dongle (aka FTDI Stick) R9M (previously flashed with ExpressLRS) \ud83d\udce1 any ESP 8266/8285 based chip should work, recommended are ESP01F for quick install (internal resistors ease initial flashing, but wire antenna) ESP12F for pcb wifi antenna, FCC/CE certififed (but more complex circuit required for initial flashing) very thin wire (AWG30 \"kynar\"); or enameled wire if you are good with routing (0.5mm holes in PCB) depending on your soldering skill using flux and leaded solder is recommended Board ESP01F (ESP8285) \u00b6 Connect the serial adapter to 3.3V , GND , TX and RX \ud83d\udd25 3.3V NOT 5V Additionally, connect IO0 to GND to activate the bootloader and enable flashing Quite some serial adapters have TX and RX swapped, mislabeled, or both \ud83d\ude38. Please double check! Board ESP12F (ESP8266) \u00b6 This module needs a more complex circuit to get flashed: PlatformIO \u00b6 The platformio sub-project is in src/ESPbackpack , please get into there first. Now, please call pio run -e ESP_BACKPACK_ESP8266 -t upload or optionally specify the serial adapter to be used pio run -e ESP_BACKPACK_ESP8266 -t upload --upload-port /dev/cu.SLAB_USBtoUART For 8285 please set the value of parameter -e to ESP_BACKPACK_ESP8285 . Connecting to R9M Module \u00b6 Let's get together: Solder wires connecting RX1 , TX1 , NRESET , and BOOT0 pins \ud83d\udd0c \u2757 Removing transistor J6 is not required in contrary to as shown on the picture Please note the alternative location to reach TX1 to keep you from having to solder on the chip's leg \ud83d\udc81 Connecting to Happymodel ELRS915TX \u00b6 The ESP module is wired: NRSET -> ESP DIO5 BOOT0 -> ESP DIO4 TX -> ESP RX RX -> ESP TX 3.3v -> ESP 3.3v GND -> ESP GND Updating the ELRS915TX over wifi is supported from 1.0.0 RC8 onwards. Connect via WiFi \u00b6 Initially, the module will open an accesspoint for you to connect and change the settings to your desire. This accesspoint is available at the ESP Wifi Manager wifi network. Then navigate to http://elrs_tx.local/ , and after building your firmware, upload the file to the website and flash. Why does the ES24TX have a wifi AP, is there any way to turn it off? \u00b6 No, there is no way to disable it, HappyModel should not have put any firmware on it. You're welcome to wipe it with esptool.","title":"ESP Backpack"},{"location":"hardware/esp-backpack/#parts","text":"USB to Serial Dongle (aka FTDI Stick) R9M (previously flashed with ExpressLRS) \ud83d\udce1 any ESP 8266/8285 based chip should work, recommended are ESP01F for quick install (internal resistors ease initial flashing, but wire antenna) ESP12F for pcb wifi antenna, FCC/CE certififed (but more complex circuit required for initial flashing) very thin wire (AWG30 \"kynar\"); or enameled wire if you are good with routing (0.5mm holes in PCB) depending on your soldering skill using flux and leaded solder is recommended","title":"Parts"},{"location":"hardware/esp-backpack/#board-esp01f-esp8285","text":"Connect the serial adapter to 3.3V , GND , TX and RX \ud83d\udd25 3.3V NOT 5V Additionally, connect IO0 to GND to activate the bootloader and enable flashing Quite some serial adapters have TX and RX swapped, mislabeled, or both \ud83d\ude38. Please double check!","title":"Board ESP01F (ESP8285)"},{"location":"hardware/esp-backpack/#board-esp12f-esp8266","text":"This module needs a more complex circuit to get flashed:","title":"Board ESP12F (ESP8266)"},{"location":"hardware/esp-backpack/#platformio","text":"The platformio sub-project is in src/ESPbackpack , please get into there first. Now, please call pio run -e ESP_BACKPACK_ESP8266 -t upload or optionally specify the serial adapter to be used pio run -e ESP_BACKPACK_ESP8266 -t upload --upload-port /dev/cu.SLAB_USBtoUART For 8285 please set the value of parameter -e to ESP_BACKPACK_ESP8285 .","title":"PlatformIO"},{"location":"hardware/esp-backpack/#connecting-to-r9m-module","text":"Let's get together: Solder wires connecting RX1 , TX1 , NRESET , and BOOT0 pins \ud83d\udd0c \u2757 Removing transistor J6 is not required in contrary to as shown on the picture Please note the alternative location to reach TX1 to keep you from having to solder on the chip's leg \ud83d\udc81","title":"Connecting to R9M Module"},{"location":"hardware/esp-backpack/#connecting-to-happymodel-elrs915tx","text":"The ESP module is wired: NRSET -> ESP DIO5 BOOT0 -> ESP DIO4 TX -> ESP RX RX -> ESP TX 3.3v -> ESP 3.3v GND -> ESP GND Updating the ELRS915TX over wifi is supported from 1.0.0 RC8 onwards.","title":"Connecting to Happymodel ELRS915TX"},{"location":"hardware/esp-backpack/#connect-via-wifi","text":"Initially, the module will open an accesspoint for you to connect and change the settings to your desire. This accesspoint is available at the ESP Wifi Manager wifi network. Then navigate to http://elrs_tx.local/ , and after building your firmware, upload the file to the website and flash.","title":"Connect via WiFi"},{"location":"hardware/esp-backpack/#why-does-the-es24tx-have-a-wifi-ap-is-there-any-way-to-turn-it-off","text":"No, there is no way to disable it, HappyModel should not have put any firmware on it. You're welcome to wipe it with esptool.","title":"Why does the ES24TX have a wifi AP, is there any way to turn it off?"},{"location":"hardware/fan-mod/","text":"R9M Fan Mod \u00b6 Initially this mod is brought to life by Niklas Voigt and Seba112PL as beta tester and is still a work in progress.. if you have suggestions don't hesitate to contact. 1W Mod \u00b6 \u26a0\ufe0f With this mod your R9M can handle 1W max You need a 20x20mm or 25x25mm fan in 5V version. Both sizes are supported. To secure the fan into the cover you can use 2x M2 screws , a thread is already in the print. U can solder the pins of the fan directly to the 5v port of the R9M or use the Controllable Fan Mod which can control the fan out of software (fan blows only at >250mw). R9M Fan Mod Cover is build out of four Parts and a Sticker: Download: \u00b6 R9M-Fan-Case-Cover.stl R9M-Fan-Case-Pins.stl R9M-Fan-Case-XT30.stl R9M-Fan-Case-Standoff.stl (2x) R9M-ExpressLRS-900Mhz.pdf or from Thingiverse Controllable Fan Mod \u00b6 Additionally to the fan you'll need one NPN Transistor (e.g. 2N4401 ) or N-Channel MOSFET (e.g. BS170 has built-in Shotky-Diode) and a resistor (200-3k7) R9M2019 Build notice \u00b6 The PB9 pad location on the R9M2019 module is a bit different. Please see the photo. 2W Mod (\u26a0\ufe0fOnly do this if you know what you are doing!\u26a0\ufe0f) \u00b6 Additionally to the 3D printed Cover & the Controllable Fan Mod you'll need: Fan + Heatsink \"2507 25MM 25x25x13MM Hydraulic bearing Graphics card Cooling fan with heat sink 5V 12V m.2 SSD Fan with 2pin\" Thermalpad 0.5mm \"1pc 100mmx100mmx0.5mm GPU Northbridge IC LED Chipset Heatsink Cooling Conductive Silicone Thermal Pad,100x100x0.5mm w/ 3.2W/M-K\" The screw heads are cut off to reduce height. > If you can see in picture 3, the 5v fan is connected to the power source of the module, so the fan is used with some overvoltage and spins with higher rpm... tested for a long time and should not be a problem for the fan. If you don't know how to allow the 2W in the firmware, don't do this mod!\ud83e\udd26\u200d\u2642\ufe0f Here are some makes: \u00b6","title":"R9M Fan Mod"},{"location":"hardware/fan-mod/#r9m-fan-mod","text":"Initially this mod is brought to life by Niklas Voigt and Seba112PL as beta tester and is still a work in progress.. if you have suggestions don't hesitate to contact.","title":"R9M Fan Mod"},{"location":"hardware/fan-mod/#1w-mod","text":"\u26a0\ufe0f With this mod your R9M can handle 1W max You need a 20x20mm or 25x25mm fan in 5V version. Both sizes are supported. To secure the fan into the cover you can use 2x M2 screws , a thread is already in the print. U can solder the pins of the fan directly to the 5v port of the R9M or use the Controllable Fan Mod which can control the fan out of software (fan blows only at >250mw). R9M Fan Mod Cover is build out of four Parts and a Sticker:","title":"1W Mod"},{"location":"hardware/fan-mod/#download","text":"R9M-Fan-Case-Cover.stl R9M-Fan-Case-Pins.stl R9M-Fan-Case-XT30.stl R9M-Fan-Case-Standoff.stl (2x) R9M-ExpressLRS-900Mhz.pdf or from Thingiverse","title":"Download:"},{"location":"hardware/fan-mod/#controllable-fan-mod","text":"Additionally to the fan you'll need one NPN Transistor (e.g. 2N4401 ) or N-Channel MOSFET (e.g. BS170 has built-in Shotky-Diode) and a resistor (200-3k7)","title":"Controllable Fan Mod"},{"location":"hardware/fan-mod/#r9m2019-build-notice","text":"The PB9 pad location on the R9M2019 module is a bit different. Please see the photo.","title":"R9M2019 Build notice"},{"location":"hardware/fan-mod/#2w-mod-only-do-this-if-you-know-what-you-are-doing","text":"Additionally to the 3D printed Cover & the Controllable Fan Mod you'll need: Fan + Heatsink \"2507 25MM 25x25x13MM Hydraulic bearing Graphics card Cooling fan with heat sink 5V 12V m.2 SSD Fan with 2pin\" Thermalpad 0.5mm \"1pc 100mmx100mmx0.5mm GPU Northbridge IC LED Chipset Heatsink Cooling Conductive Silicone Thermal Pad,100x100x0.5mm w/ 3.2W/M-K\" The screw heads are cut off to reduce height. > If you can see in picture 3, the 5v fan is connected to the power source of the module, so the fan is used with some overvoltage and spins with higher rpm... tested for a long time and should not be a problem for the fan. If you don't know how to allow the 2W in the firmware, don't do this mod!\ud83e\udd26\u200d\u2642\ufe0f","title":"2W Mod (\u26a0\ufe0fOnly do this if you know what you are doing!\u26a0\ufe0f)"},{"location":"hardware/fan-mod/#here-are-some-makes","text":"","title":"Here are some makes:"},{"location":"hardware/inverter-mod/","text":"To benefit from the higher bitrate of 400 kilobit per second using OpenTX you need to add a pullup resistor to the inverter of the serial port on the R9M 2018\ud83d\uddfb\ud83c\udd99 Strongly suggested to be done for anybody looking for higher than standard packet rates using ExpressLRS \ud83d\udd2e Identification \u00b6 \u26a0\ufe0f This is only required for the 2018 version of the module which has a ACCST logo on the case \ud83d\udd0d Modification \u00b6 Easy - connect a 300\u03a9 to 1000\u03a9 resistor between the 3.3V and inverter pin as shown on the picture \ud83d\udc67 Transmitter Notes \u00b6 X9D only does 400 kbit/s and does not allow lowering the bitrate to 115200 bit/s - 400k Mod is not required. X10S Express 400k Mod is not required. X10S modification is required \ud83d\ude45 X12 modification is required \ud83d\ude45 QX7 allows configuration of the bitrate in the OpenTX hardware menu. ELRS will work fine using 115200 bit/s but the modification is required for 400 kbit/s \ud83d\ude45\u200d\u2640\ufe0f The modification is not needed for ACCESS radios","title":"R9M Inverter Mod"},{"location":"hardware/inverter-mod/#identification","text":"\u26a0\ufe0f This is only required for the 2018 version of the module which has a ACCST logo on the case \ud83d\udd0d","title":"Identification"},{"location":"hardware/inverter-mod/#modification","text":"Easy - connect a 300\u03a9 to 1000\u03a9 resistor between the 3.3V and inverter pin as shown on the picture \ud83d\udc67","title":"Modification"},{"location":"hardware/inverter-mod/#transmitter-notes","text":"X9D only does 400 kbit/s and does not allow lowering the bitrate to 115200 bit/s - 400k Mod is not required. X10S Express 400k Mod is not required. X10S modification is required \ud83d\ude45 X12 modification is required \ud83d\ude45 QX7 allows configuration of the bitrate in the OpenTX hardware menu. ELRS will work fine using 115200 bit/s but the modification is required for 400 kbit/s \ud83d\ude45\u200d\u2640\ufe0f The modification is not needed for ACCESS radios","title":"Transmitter Notes"},{"location":"hardware/smd-antenna/","text":"Have you ever been frustrated that you can't finish a race because your receiver antenna got chopped? Have you ever wished you could build a quad without worrying about how to mount your antenna? If so, the SMD Antenna is for you! This perky little fellow is worse at receiving signals than his snaky brothers, but don't let that deter you! Because of the amazing range of ExpressLRS, he still gets all the range a racer could ever need. The SMD Antenna is available now on Happymodel PP/EP hardware and other 2.4GHz receivers. Take a look at the videos below to see what Mr. SMD can do for you. Range Tests \u00b6 3km flight on 500hz: https://www.youtube.com/watch?v=kfa6ugX46n8 Parking Garage on 500Hz: https://www.youtube.com/watch?v=Fr7CCeni2dY Range Comparison to Dipole: https://www.youtube.com/watch?v=A5w81n5qV1M RSSI Comparison Dipole: https://youtu.be/CnaEe7YZB-Q Maintenance \u00b6 Note: The antenna is sorta fragile and can break off or be melted by a stray soldering iron. If this happens, you can save your receiver by soldering a U.FL/IPEX1 connector onto the pads like shown here. Just make sure the center pin has continuity with the filter at the other end of the trace, and no continuity with ground. Conversely, the SMD antenna can be soldered to regular U.FL footprints if you're brave.","title":"SMD Antenna"},{"location":"hardware/smd-antenna/#range-tests","text":"3km flight on 500hz: https://www.youtube.com/watch?v=kfa6ugX46n8 Parking Garage on 500Hz: https://www.youtube.com/watch?v=Fr7CCeni2dY Range Comparison to Dipole: https://www.youtube.com/watch?v=A5w81n5qV1M RSSI Comparison Dipole: https://youtu.be/CnaEe7YZB-Q","title":"Range Tests"},{"location":"hardware/smd-antenna/#maintenance","text":"Note: The antenna is sorta fragile and can break off or be melted by a stray soldering iron. If this happens, you can save your receiver by soldering a U.FL/IPEX1 connector onto the pads like shown here. Just make sure the center pin has continuity with the filter at the other end of the trace, and no continuity with ground. Conversely, the SMD antenna can be soldered to regular U.FL footprints if you're brave.","title":"Maintenance"},{"location":"hardware/spi-receivers/","text":"A few Flight Controllers and AIOs have been released with ExpressLRS receivers on-board using SPI instead of a regular UART. This means you can build a more compact and lightweight whoop or nano longrange rig without the need for an external receiver. More of these flight controllers are coming into stores. Because these are SPI-based, the ExpressLRS Code came baked-in in the Betaflight 4.3.0-based custom-built firmware. These usually don't need to be updated. These Flight Controllers will work with any released ExpressLRS firmware. Binding Procedure \u00b6 There are two ways to bind the receiver, as shown below Button Binding \u00b6 Put the receiver into bind mode using any of these procedures: \"Bind\" button in the Betaflight Configurator, Receiver Page (if can't be found, update the Betaflight firmware). using the CLI, type in bind_rx and press enter once. press the bind button on the flight controller. using the CLI, type in set expresslrs_uid = 0 , press enter once, then save and reboot Enter elrs.lua in your handset and press the Bind button. The RX and TX should be now bound. Please mind the order, RX first, TX second. Video Tutorial (thanks to @JyeSmith ): Passphrase \u00b6 Set passphrase in the TX. When building via ExpressLRS configurator, or via VS Code note down and copy below numbers from the build log: Go to betaflight cli and type (for example): set expresslrs_uid = 172,123,235,247,1,122 save Updating \u00b6 As mentioned, there's little need to update, but should you still want to, the update will mean you will reflash your Betaflight firmware into your Flight Controller. In preparation for this, you should save a copy of your diff all dump. Download the necessary binaries (zipped) from this Betaflight PR page . Extract the Hex File and, using Betaflight Configurator 10.8.0 (Nightly), flash the binary using the Load Firmware [Local] button found at the bottom right of the Firmware Flasher (Flight Controller in DFU Mode). Once flashed, you will need to paste in the diff all you have saved. Don't forget to type in save and press enter once done. Power cycle your flight controller, and you should be set. Review your Betaflight settings, and check your RC link. This procedure will only apply while Betaflight 4.3.0 is not yet released. Section will be updated appropriately for any changes in procedures. For more information, head over to the Betaflight PR page . We can also help out over at Discord ! Content taken from the PR page \u2105 of @phobos-","title":"SPI Receivers"},{"location":"hardware/spi-receivers/#binding-procedure","text":"There are two ways to bind the receiver, as shown below","title":"Binding Procedure"},{"location":"hardware/spi-receivers/#button-binding","text":"Put the receiver into bind mode using any of these procedures: \"Bind\" button in the Betaflight Configurator, Receiver Page (if can't be found, update the Betaflight firmware). using the CLI, type in bind_rx and press enter once. press the bind button on the flight controller. using the CLI, type in set expresslrs_uid = 0 , press enter once, then save and reboot Enter elrs.lua in your handset and press the Bind button. The RX and TX should be now bound. Please mind the order, RX first, TX second. Video Tutorial (thanks to @JyeSmith ):","title":"Button Binding"},{"location":"hardware/spi-receivers/#passphrase","text":"Set passphrase in the TX. When building via ExpressLRS configurator, or via VS Code note down and copy below numbers from the build log: Go to betaflight cli and type (for example): set expresslrs_uid = 172,123,235,247,1,122 save","title":"Passphrase"},{"location":"hardware/spi-receivers/#updating","text":"As mentioned, there's little need to update, but should you still want to, the update will mean you will reflash your Betaflight firmware into your Flight Controller. In preparation for this, you should save a copy of your diff all dump. Download the necessary binaries (zipped) from this Betaflight PR page . Extract the Hex File and, using Betaflight Configurator 10.8.0 (Nightly), flash the binary using the Load Firmware [Local] button found at the bottom right of the Firmware Flasher (Flight Controller in DFU Mode). Once flashed, you will need to paste in the diff all you have saved. Don't forget to type in save and press enter once done. Power cycle your flight controller, and you should be set. Review your Betaflight settings, and check your RC link. This procedure will only apply while Betaflight 4.3.0 is not yet released. Section will be updated appropriately for any changes in procedures. For more information, head over to the Betaflight PR page . We can also help out over at Discord ! Content taken from the PR page \u2105 of @phobos-","title":"Updating"},{"location":"hardware/supported-hardware/","text":"This is the hardware landing page! Welcome in. To navigate through this (large) subsection, use the sidebar on the left . These pages show information on certain modifications to hardware, and certain ELRS specific hardware. More and more manufacturers are coming up with their own take of the ExpressLRS Hardware and the list keeps growing. At the time of writing, here are the ExpressLRS-supported Transmitter Modules and Receivers, along with a few Flight Controllers and AIO boards. 2.4GHz Transmitter modules \u00b6 Happymodel ES24Tx \u00b6 Flashing Guide Manufacturer Website NamimnoRC Flash \u00b6 Flashing Guide BetaFPV Nano 2.4GHz \u00b6 Flashing Guide Manufacturer Website Ghost TX \u00b6 Flashing Guide Note: STLink first time flash, irreversible Siyi FM30 \u00b6 Flashing Guide 2.4GHz Receivers \u00b6 Happymodel EP1 & EP2 \u00b6 Flashing Guide Manufacturer Website Happymodel PP \u00b6 Flashing Guide Manufacturer Website NamimnoRC Flash \u00b6 Flashing Guide BetaFPV Nano 2.4GHz \u00b6 Flashing Guide Manufacturer Website Ghost Atto Receivers \u00b6 Flashing Guide Note: STLink first time flash, irreversible Siyi FR Mini \u00b6 Flashing Guide 900Mhz Transmitter Modules \u00b6 Frsky R9M (inc. Lite & Lite Pro) \u00b6 Flashing Guide Happymodel ES900TX \u00b6 Flashing Guide Manufacturer Website NamimnoRC Voyager \u00b6 Flashing Guide BetaFPV Nano 900Mhz \u00b6 Flashing Guide Manufacturer Website 900Mhz Receivers \u00b6 Frsky R9 Receivers \u00b6 R9MM R9 Mini R9MX R9 Slim R9 Slim+ Flashing Guide Jumper R9 Mini \u00b6 Flashing Guide Happymodel ES900RX \u00b6 Flashing Guide Manufacturer Website NamimnoRC Voyager \u00b6 Flashing Guide BetaFPV Nano 900Mhz \u00b6 Flashing Guide Manufacturer Website Flight Controllers with onboard ExpressLRS Receivers \u00b6 Happymodel ELRS F4 2G4 AIO \u00b6 Manufacturer Website Note: SPI-based receiver. Doesn't need the ExpressLRS Configurator for updates. See this page for more info. Happymodel CrazyF4 ELRS AIO 900Mhz \u00b6 Manufacturer Website Note: Receiver firmware can be updated using the ES915/868RX methods. BetaFPV F4 1S 12A AIO \u00b6 Manufacturer Website Note: Receiver firmware can be updated using the Beta FPV Nano 2.4GHz methods SPRacing H7RF \u00b6 Manufacturer Website Note: SPI-based receiver. Doesn't need the ExpressLRS Configurator for updates. See this page for more info. DIY TX Modules \u00b6 See this page here DIY Receivers \u00b6 See this page here","title":"Supported Hardware"},{"location":"hardware/supported-hardware/#24ghz-transmitter-modules","text":"","title":"2.4GHz Transmitter modules"},{"location":"hardware/supported-hardware/#happymodel-es24tx","text":"Flashing Guide Manufacturer Website","title":"Happymodel ES24Tx"},{"location":"hardware/supported-hardware/#namimnorc-flash","text":"Flashing Guide","title":"NamimnoRC Flash"},{"location":"hardware/supported-hardware/#betafpv-nano-24ghz","text":"Flashing Guide Manufacturer Website","title":"BetaFPV Nano 2.4GHz"},{"location":"hardware/supported-hardware/#ghost-tx","text":"Flashing Guide Note: STLink first time flash, irreversible","title":"Ghost TX"},{"location":"hardware/supported-hardware/#siyi-fm30","text":"Flashing Guide","title":"Siyi FM30"},{"location":"hardware/supported-hardware/#24ghz-receivers","text":"","title":"2.4GHz Receivers"},{"location":"hardware/supported-hardware/#happymodel-ep1-ep2","text":"Flashing Guide Manufacturer Website","title":"Happymodel EP1 &amp; EP2"},{"location":"hardware/supported-hardware/#happymodel-pp","text":"Flashing Guide Manufacturer Website","title":"Happymodel PP"},{"location":"hardware/supported-hardware/#namimnorc-flash_1","text":"Flashing Guide","title":"NamimnoRC Flash"},{"location":"hardware/supported-hardware/#betafpv-nano-24ghz_1","text":"Flashing Guide Manufacturer Website","title":"BetaFPV Nano 2.4GHz"},{"location":"hardware/supported-hardware/#ghost-atto-receivers","text":"Flashing Guide Note: STLink first time flash, irreversible","title":"Ghost Atto Receivers"},{"location":"hardware/supported-hardware/#siyi-fr-mini","text":"Flashing Guide","title":"Siyi FR Mini"},{"location":"hardware/supported-hardware/#900mhz-transmitter-modules","text":"","title":"900Mhz Transmitter Modules"},{"location":"hardware/supported-hardware/#frsky-r9m-inc-lite-lite-pro","text":"Flashing Guide","title":"Frsky R9M (inc. Lite &amp; Lite Pro)"},{"location":"hardware/supported-hardware/#happymodel-es900tx","text":"Flashing Guide Manufacturer Website","title":"Happymodel ES900TX"},{"location":"hardware/supported-hardware/#namimnorc-voyager","text":"Flashing Guide","title":"NamimnoRC Voyager"},{"location":"hardware/supported-hardware/#betafpv-nano-900mhz","text":"Flashing Guide Manufacturer Website","title":"BetaFPV Nano 900Mhz"},{"location":"hardware/supported-hardware/#900mhz-receivers","text":"","title":"900Mhz Receivers"},{"location":"hardware/supported-hardware/#frsky-r9-receivers","text":"R9MM R9 Mini R9MX R9 Slim R9 Slim+ Flashing Guide","title":"Frsky R9 Receivers"},{"location":"hardware/supported-hardware/#jumper-r9-mini","text":"Flashing Guide","title":"Jumper R9 Mini"},{"location":"hardware/supported-hardware/#happymodel-es900rx","text":"Flashing Guide Manufacturer Website","title":"Happymodel ES900RX"},{"location":"hardware/supported-hardware/#namimnorc-voyager_1","text":"Flashing Guide","title":"NamimnoRC Voyager"},{"location":"hardware/supported-hardware/#betafpv-nano-900mhz_1","text":"Flashing Guide Manufacturer Website","title":"BetaFPV Nano 900Mhz"},{"location":"hardware/supported-hardware/#flight-controllers-with-onboard-expresslrs-receivers","text":"","title":"Flight Controllers with onboard ExpressLRS Receivers"},{"location":"hardware/supported-hardware/#happymodel-elrs-f4-2g4-aio","text":"Manufacturer Website Note: SPI-based receiver. Doesn't need the ExpressLRS Configurator for updates. See this page for more info.","title":"Happymodel ELRS F4 2G4 AIO"},{"location":"hardware/supported-hardware/#happymodel-crazyf4-elrs-aio-900mhz","text":"Manufacturer Website Note: Receiver firmware can be updated using the ES915/868RX methods.","title":"Happymodel CrazyF4 ELRS AIO 900Mhz"},{"location":"hardware/supported-hardware/#betafpv-f4-1s-12a-aio","text":"Manufacturer Website Note: Receiver firmware can be updated using the Beta FPV Nano 2.4GHz methods","title":"BetaFPV F4 1S 12A AIO"},{"location":"hardware/supported-hardware/#spracing-h7rf","text":"Manufacturer Website Note: SPI-based receiver. Doesn't need the ExpressLRS Configurator for updates. See this page for more info.","title":"SPRacing H7RF"},{"location":"hardware/supported-hardware/#diy-tx-modules","text":"See this page here","title":"DIY TX Modules"},{"location":"hardware/supported-hardware/#diy-receivers","text":"See this page here","title":"DIY Receivers"},{"location":"hardware/x9d-troubleshooting/","text":"For quite some time we had the impression that the X9D(+) radio works well with high baud rates, needed for ExpressLRS. However some users report it's not working as it should with ExpressLRS. For example: ExpressLRS Lua script just shows Connecting... ExpressLRS Lua script shows unstable behavior, especially on the higher packet rates, showing values different from 0:['SELECTED PACKET RATE'] Constant Telemety Lost/Telemetry Recovered Notification. So what could be wrong? \u00b6 It is possible that the X9D(+) radio also suffers from a slow inverter circuit that messes up the 400000 baud UART signals. As you maybe know, for the Taranis QX7(S) you can do the Crossfire inverter mod or select a lower baud rate in the Hardware menu (Page 6/7) of OpenTX to fix the issue. Can it be fixed? \u00b6 Well, the final verdict is not out yet, but the following may help to resolve the issue: Do a hardware mod as well on your X9D(+) as you can read all about here in PR# 59 for EdgeTX. This requires changing the 10k resistor R82 to a 1k resistor. Download a OneBit_Status firmware using this OpenTX version , based on OpenTX 2.3.12 and enable ONEBIT Select 115200 baud using the above OpenTX version. (ExpressLRS will lock you out on 500Hz packet rate, but below that rate should be stable now.) The nice thing about the OpenTX build above is that it also adds two additional Sync lines to show the current OpenTX/UART behavior. This will show in your Model Setup (Page 2/11) where you select the external module type (where you selected CRSF to enable ELRS): The first Sync line shows something like L00002R04000u . L and R indicates the microseconds of Lag and Rate. The L is how much OpenTX is trying to compensate to nail the rate you selected. (The closer to 0 the better) The R is just the Packet Rate you selected using the ExpressLRS Lua script. The second Sync line shows something like G11 C00 F00 . This stand for G (good packets), C (CRC error), F (Framing error). The goal is to have zero errors here. (Don't forget to power your receiver so a link is established!) If this has helped you in any way (good or bad) with your X9D(+) radio, let us know on the ExpressLRS discord!","title":"Troubleshooting the X9D(+)"},{"location":"hardware/x9d-troubleshooting/#so-what-could-be-wrong","text":"It is possible that the X9D(+) radio also suffers from a slow inverter circuit that messes up the 400000 baud UART signals. As you maybe know, for the Taranis QX7(S) you can do the Crossfire inverter mod or select a lower baud rate in the Hardware menu (Page 6/7) of OpenTX to fix the issue.","title":"So what could be wrong?"},{"location":"hardware/x9d-troubleshooting/#can-it-be-fixed","text":"Well, the final verdict is not out yet, but the following may help to resolve the issue: Do a hardware mod as well on your X9D(+) as you can read all about here in PR# 59 for EdgeTX. This requires changing the 10k resistor R82 to a 1k resistor. Download a OneBit_Status firmware using this OpenTX version , based on OpenTX 2.3.12 and enable ONEBIT Select 115200 baud using the above OpenTX version. (ExpressLRS will lock you out on 500Hz packet rate, but below that rate should be stable now.) The nice thing about the OpenTX build above is that it also adds two additional Sync lines to show the current OpenTX/UART behavior. This will show in your Model Setup (Page 2/11) where you select the external module type (where you selected CRSF to enable ELRS): The first Sync line shows something like L00002R04000u . L and R indicates the microseconds of Lag and Rate. The L is how much OpenTX is trying to compensate to nail the rate you selected. (The closer to 0 the better) The R is just the Packet Rate you selected using the ExpressLRS Lua script. The second Sync line shows something like G11 C00 F00 . This stand for G (good packets), C (CRC error), F (Framing error). The goal is to have zero errors here. (Don't forget to power your receiver so a link is established!) If this has helped you in any way (good or bad) with your X9D(+) radio, let us know on the ExpressLRS discord!","title":"Can it be fixed?"},{"location":"info/crc-testing/","text":"After performing CRC tests using the CRC-13 it was found that CRC basically includes parity checking so adding a seperate parity check was wasteful. CRC checking has now been updated to 14-bit. The following tests were performed using the new CRC-14 bit implementation with a polynomial of 0x372B, which gives a hamming distance of 6 in a 57-bit range. What this means is that it can detect up to 5 randomly flipped bits a message that is 57 bits long. Three stress tests have been performed on the 50-bit data with CRC-14. The tests create random data in 7 bytes (the first byte only has the lower 2 bits set) then perform random bit flipping based on three styles. Bear in mind that the CRC is not in the data and so is not subject to bit flipping. Random flipped bits within 14-bit range \u00b6 Anything over 14 is fairly useless as it will just flip bits back! 1 : 0 out of 1000000 false positives, 0.000000% 2 : 0 out of 1000000 false positives, 0.000000% 3 : 0 out of 1000000 false positives, 0.000000% 4 : 0 out of 1000000 false positives, 0.000000% 5 : 0 out of 1000000 false positives, 0.000000% 6 : 0 out of 1000000 false positives, 0.000000% 7 : 0 out of 1000000 false positives, 0.000000% 8 : 0 out of 1000000 false positives, 0.000000% 9 : 0 out of 1000000 false positives, 0.000000% 10 : 0 out of 1000000 false positives, 0.000000% 11 : 0 out of 1000000 false positives, 0.000000% 12 : 0 out of 1000000 false positives, 0.000000% 13 : 0 out of 1000000 false positives, 0.000000% 14 : 0 out of 1000000 false positives, 0.000000% 15 : 0 out of 1000000 false positives, 0.000000% 16 : 0 out of 1000000 false positives, 0.000000% 17 : 0 out of 1000000 false positives, 0.000000% 18 : 0 out of 1000000 false positives, 0.000000% 19 : 0 out of 1000000 false positives, 0.000000% 20 : 0 out of 1000000 false positives, 0.000000% 21 : 0 out of 1000000 false positives, 0.000000% 22 : 0 out of 1000000 false positives, 0.000000% 23 : 0 out of 1000000 false positives, 0.000000% 24 : 0 out of 1000000 false positives, 0.000000% 25 : 0 out of 1000000 false positives, 0.000000% 26 : 0 out of 1000000 false positives, 0.000000% 27 : 0 out of 1000000 false positives, 0.000000% 28 : 0 out of 1000000 false positives, 0.000000% 29 : 0 out of 1000000 false positives, 0.000000% 30 : 0 out of 1000000 false positives, 0.000000% Flipped bits in a single sequence at random start position \u00b6 The number 1-30 is the number of consecutive bits that are flipped at a random starting position. 1 : 0 out of 1000000 false positives, 0.000000% 2 : 0 out of 1000000 false positives, 0.000000% 3 : 0 out of 1000000 false positives, 0.000000% 4 : 0 out of 1000000 false positives, 0.000000% 5 : 0 out of 1000000 false positives, 0.000000% 6 : 0 out of 1000000 false positives, 0.000000% 7 : 0 out of 1000000 false positives, 0.000000% 8 : 0 out of 1000000 false positives, 0.000000% 9 : 0 out of 1000000 false positives, 0.000000% 10 : 0 out of 1000000 false positives, 0.000000% 11 : 0 out of 1000000 false positives, 0.000000% 12 : 0 out of 1000000 false positives, 0.000000% 13 : 0 out of 1000000 false positives, 0.000000% 14 : 0 out of 1000000 false positives, 0.000000% 15 : 0 out of 1000000 false positives, 0.000000% 16 : 0 out of 1000000 false positives, 0.000000% 17 : 0 out of 1000000 false positives, 0.000000% 18 : 0 out of 1000000 false positives, 0.000000% 19 : 0 out of 1000000 false positives, 0.000000% 20 : 0 out of 1000000 false positives, 0.000000% 21 : 0 out of 1000000 false positives, 0.000000% 22 : 0 out of 1000000 false positives, 0.000000% 23 : 0 out of 1000000 false positives, 0.000000% 24 : 0 out of 1000000 false positives, 0.000000% 25 : 0 out of 1000000 false positives, 0.000000% 26 : 0 out of 1000000 false positives, 0.000000% 27 : 0 out of 1000000 false positives, 0.000000% 28 : 0 out of 1000000 false positives, 0.000000% 29 : 0 out of 1000000 false positives, 0.000000% 30 : 0 out of 1000000 false positives, 0.000000% Randomly flipped bits \u00b6 Interestingly this is where the hamming distance shows an any flipped bits less that HD6 are detected. Also this is where the built-in parity shows up as it detects the odd numbered bit flips. 1 : 0 out of 1000000 false positives, 0.000000% 2 : 0 out of 1000000 false positives, 0.000000% 3 : 0 out of 1000000 false positives, 0.000000% 4 : 0 out of 1000000 false positives, 0.000000% 5 : 0 out of 1000000 false positives, 0.000000% 6 : 101 out of 1000000 false positives, 0.010100% 7 : 0 out of 1000000 false positives, 0.000000% 8 : 134 out of 1000000 false positives, 0.013400% 9 : 0 out of 1000000 false positives, 0.000000% 10 : 129 out of 1000000 false positives, 0.012900% 11 : 0 out of 1000000 false positives, 0.000000% 12 : 123 out of 1000000 false positives, 0.012300% 13 : 0 out of 1000000 false positives, 0.000000% 14 : 116 out of 1000000 false positives, 0.011600% 15 : 0 out of 1000000 false positives, 0.000000% 16 : 106 out of 1000000 false positives, 0.010600% 17 : 0 out of 1000000 false positives, 0.000000% 18 : 113 out of 1000000 false positives, 0.011300% 19 : 0 out of 1000000 false positives, 0.000000% 20 : 118 out of 1000000 false positives, 0.011800% 21 : 0 out of 1000000 false positives, 0.000000% 22 : 131 out of 1000000 false positives, 0.013100% 23 : 0 out of 1000000 false positives, 0.000000% 24 : 102 out of 1000000 false positives, 0.010200% 25 : 0 out of 1000000 false positives, 0.000000% 26 : 111 out of 1000000 false positives, 0.011100% 27 : 0 out of 1000000 false positives, 0.000000% 28 : 159 out of 1000000 false positives, 0.015900% 29 : 0 out of 1000000 false positives, 0.000000% 30 : 116 out of 1000000 false positives, 0.011600% OTA Testing \u00b6 A 5hr OTA soak test was done at RSSI -108dBm (2.4GHz, 500Hz) and branch https://github.com/ExpressLRS/ExpressLRS/commit/e3ddcc . RC data bytes were hard coded 0xAA and checked for CRC14 pass/fail, and the number of bits flipped counted. The below table columns are the number of bits flipped, crc passed tally, crc failed tally. Where passed means a bad packet that passes the CRC check and would accepted by the RX. On the 0 row, Passed is good, Failed is where the data is good, but the CRC itself was changed by bit-flips. CRC | Passed | Failed 0 | 5589423 | 55438 1 | 0 | 68262 2 | 0 | 81015 3 | 0 | 37478 4 | 2 | 32449 5 | 0 | 18546 6 | 0 | 20082 7 | 1 | 12697 8 | 0 | 12433 9 | 0 | 9803 10 | 1 | 8899 11 | 0 | 7462 12 | 0 | 6105 13 | 1 | 4720 14 | 0 | 3858 15 | 0 | 3170 16 | 1 | 2673 17 | 0 | 2159 18 | 1 | 1980 19 | 0 | 1746 20 | 1 | 1703 21 | 0 | 1449 22 | 0 | 1332 23 | 0 | 1076 24 | 0 | 833 25 | 0 | 565 26 | 0 | 454 27 | 0 | 353 28 | 0 | 288 29 | 0 | 210 30 | 0 | 168 31 | 0 | 92 32 | 0 | 39 33 | 0 | 25 34 | 0 | 5 35 | 0 | 2 36 | 0 | 0 37 | 0 | 0 38 | 0 | 0 39 | 0 | 0 1hr soak test at -100dBm CRC | Passed | Failed 0 | 1450923 | 10 1 | 0 | 6 2 | 0 | 34 3 | 0 | 5 4 | 0 | 10 5 | 0 | 1 6 | 0 | 3 7 | 0 | 2 8 | 0 | 0 9 | 0 | 1 10 | 0 | 1 11 | 0 | 3 12 | 0 | 0 13 | 0 | 0 14 | 0 | 0 15 | 0 | 0 16 | 0 | 0 17 | 0 | 0 18 | 0 | 1 19 | 0 | 0 20 | 0 | 0 21 | 0 | 0 22 | 0 | 0 23 | 0 | 0 24 | 0 | 0 25 | 0 | 0 26 | 0 | 0 27 | 0 | 0 28 | 0 | 0 29 | 0 | 0 30 | 0 | 0 31 | 0 | 0 32 | 0 | 0 33 | 0 | 0 34 | 0 | 0 35 | 0 | 0 36 | 0 | 0 37 | 0 | 0 38 | 0 | 0 39 | 0 | 0","title":"CRC Testing"},{"location":"info/crc-testing/#random-flipped-bits-within-14-bit-range","text":"Anything over 14 is fairly useless as it will just flip bits back! 1 : 0 out of 1000000 false positives, 0.000000% 2 : 0 out of 1000000 false positives, 0.000000% 3 : 0 out of 1000000 false positives, 0.000000% 4 : 0 out of 1000000 false positives, 0.000000% 5 : 0 out of 1000000 false positives, 0.000000% 6 : 0 out of 1000000 false positives, 0.000000% 7 : 0 out of 1000000 false positives, 0.000000% 8 : 0 out of 1000000 false positives, 0.000000% 9 : 0 out of 1000000 false positives, 0.000000% 10 : 0 out of 1000000 false positives, 0.000000% 11 : 0 out of 1000000 false positives, 0.000000% 12 : 0 out of 1000000 false positives, 0.000000% 13 : 0 out of 1000000 false positives, 0.000000% 14 : 0 out of 1000000 false positives, 0.000000% 15 : 0 out of 1000000 false positives, 0.000000% 16 : 0 out of 1000000 false positives, 0.000000% 17 : 0 out of 1000000 false positives, 0.000000% 18 : 0 out of 1000000 false positives, 0.000000% 19 : 0 out of 1000000 false positives, 0.000000% 20 : 0 out of 1000000 false positives, 0.000000% 21 : 0 out of 1000000 false positives, 0.000000% 22 : 0 out of 1000000 false positives, 0.000000% 23 : 0 out of 1000000 false positives, 0.000000% 24 : 0 out of 1000000 false positives, 0.000000% 25 : 0 out of 1000000 false positives, 0.000000% 26 : 0 out of 1000000 false positives, 0.000000% 27 : 0 out of 1000000 false positives, 0.000000% 28 : 0 out of 1000000 false positives, 0.000000% 29 : 0 out of 1000000 false positives, 0.000000% 30 : 0 out of 1000000 false positives, 0.000000%","title":"Random flipped bits within 14-bit range"},{"location":"info/crc-testing/#flipped-bits-in-a-single-sequence-at-random-start-position","text":"The number 1-30 is the number of consecutive bits that are flipped at a random starting position. 1 : 0 out of 1000000 false positives, 0.000000% 2 : 0 out of 1000000 false positives, 0.000000% 3 : 0 out of 1000000 false positives, 0.000000% 4 : 0 out of 1000000 false positives, 0.000000% 5 : 0 out of 1000000 false positives, 0.000000% 6 : 0 out of 1000000 false positives, 0.000000% 7 : 0 out of 1000000 false positives, 0.000000% 8 : 0 out of 1000000 false positives, 0.000000% 9 : 0 out of 1000000 false positives, 0.000000% 10 : 0 out of 1000000 false positives, 0.000000% 11 : 0 out of 1000000 false positives, 0.000000% 12 : 0 out of 1000000 false positives, 0.000000% 13 : 0 out of 1000000 false positives, 0.000000% 14 : 0 out of 1000000 false positives, 0.000000% 15 : 0 out of 1000000 false positives, 0.000000% 16 : 0 out of 1000000 false positives, 0.000000% 17 : 0 out of 1000000 false positives, 0.000000% 18 : 0 out of 1000000 false positives, 0.000000% 19 : 0 out of 1000000 false positives, 0.000000% 20 : 0 out of 1000000 false positives, 0.000000% 21 : 0 out of 1000000 false positives, 0.000000% 22 : 0 out of 1000000 false positives, 0.000000% 23 : 0 out of 1000000 false positives, 0.000000% 24 : 0 out of 1000000 false positives, 0.000000% 25 : 0 out of 1000000 false positives, 0.000000% 26 : 0 out of 1000000 false positives, 0.000000% 27 : 0 out of 1000000 false positives, 0.000000% 28 : 0 out of 1000000 false positives, 0.000000% 29 : 0 out of 1000000 false positives, 0.000000% 30 : 0 out of 1000000 false positives, 0.000000%","title":"Flipped bits in a single sequence at random start position"},{"location":"info/crc-testing/#randomly-flipped-bits","text":"Interestingly this is where the hamming distance shows an any flipped bits less that HD6 are detected. Also this is where the built-in parity shows up as it detects the odd numbered bit flips. 1 : 0 out of 1000000 false positives, 0.000000% 2 : 0 out of 1000000 false positives, 0.000000% 3 : 0 out of 1000000 false positives, 0.000000% 4 : 0 out of 1000000 false positives, 0.000000% 5 : 0 out of 1000000 false positives, 0.000000% 6 : 101 out of 1000000 false positives, 0.010100% 7 : 0 out of 1000000 false positives, 0.000000% 8 : 134 out of 1000000 false positives, 0.013400% 9 : 0 out of 1000000 false positives, 0.000000% 10 : 129 out of 1000000 false positives, 0.012900% 11 : 0 out of 1000000 false positives, 0.000000% 12 : 123 out of 1000000 false positives, 0.012300% 13 : 0 out of 1000000 false positives, 0.000000% 14 : 116 out of 1000000 false positives, 0.011600% 15 : 0 out of 1000000 false positives, 0.000000% 16 : 106 out of 1000000 false positives, 0.010600% 17 : 0 out of 1000000 false positives, 0.000000% 18 : 113 out of 1000000 false positives, 0.011300% 19 : 0 out of 1000000 false positives, 0.000000% 20 : 118 out of 1000000 false positives, 0.011800% 21 : 0 out of 1000000 false positives, 0.000000% 22 : 131 out of 1000000 false positives, 0.013100% 23 : 0 out of 1000000 false positives, 0.000000% 24 : 102 out of 1000000 false positives, 0.010200% 25 : 0 out of 1000000 false positives, 0.000000% 26 : 111 out of 1000000 false positives, 0.011100% 27 : 0 out of 1000000 false positives, 0.000000% 28 : 159 out of 1000000 false positives, 0.015900% 29 : 0 out of 1000000 false positives, 0.000000% 30 : 116 out of 1000000 false positives, 0.011600%","title":"Randomly flipped bits"},{"location":"info/crc-testing/#ota-testing","text":"A 5hr OTA soak test was done at RSSI -108dBm (2.4GHz, 500Hz) and branch https://github.com/ExpressLRS/ExpressLRS/commit/e3ddcc . RC data bytes were hard coded 0xAA and checked for CRC14 pass/fail, and the number of bits flipped counted. The below table columns are the number of bits flipped, crc passed tally, crc failed tally. Where passed means a bad packet that passes the CRC check and would accepted by the RX. On the 0 row, Passed is good, Failed is where the data is good, but the CRC itself was changed by bit-flips. CRC | Passed | Failed 0 | 5589423 | 55438 1 | 0 | 68262 2 | 0 | 81015 3 | 0 | 37478 4 | 2 | 32449 5 | 0 | 18546 6 | 0 | 20082 7 | 1 | 12697 8 | 0 | 12433 9 | 0 | 9803 10 | 1 | 8899 11 | 0 | 7462 12 | 0 | 6105 13 | 1 | 4720 14 | 0 | 3858 15 | 0 | 3170 16 | 1 | 2673 17 | 0 | 2159 18 | 1 | 1980 19 | 0 | 1746 20 | 1 | 1703 21 | 0 | 1449 22 | 0 | 1332 23 | 0 | 1076 24 | 0 | 833 25 | 0 | 565 26 | 0 | 454 27 | 0 | 353 28 | 0 | 288 29 | 0 | 210 30 | 0 | 168 31 | 0 | 92 32 | 0 | 39 33 | 0 | 25 34 | 0 | 5 35 | 0 | 2 36 | 0 | 0 37 | 0 | 0 38 | 0 | 0 39 | 0 | 0 1hr soak test at -100dBm CRC | Passed | Failed 0 | 1450923 | 10 1 | 0 | 6 2 | 0 | 34 3 | 0 | 5 4 | 0 | 10 5 | 0 | 1 6 | 0 | 3 7 | 0 | 2 8 | 0 | 0 9 | 0 | 1 10 | 0 | 1 11 | 0 | 3 12 | 0 | 0 13 | 0 | 0 14 | 0 | 0 15 | 0 | 0 16 | 0 | 0 17 | 0 | 0 18 | 0 | 1 19 | 0 | 0 20 | 0 | 0 21 | 0 | 0 22 | 0 | 0 23 | 0 | 0 24 | 0 | 0 25 | 0 | 0 26 | 0 | 0 27 | 0 | 0 28 | 0 | 0 29 | 0 | 0 30 | 0 | 0 31 | 0 | 0 32 | 0 | 0 33 | 0 | 0 34 | 0 | 0 35 | 0 | 0 36 | 0 | 0 37 | 0 | 0 38 | 0 | 0 39 | 0 | 0","title":"OTA Testing"},{"location":"info/glossary/","text":"Glossary \u00b6 Below you can find a list of terms you might not be sure about, as well as some common abbreviations: CRSF : TBS Crossfire, more specifialy in our case most often refering to the communication protocol between TX and TX module and RX and FC respectively OTX : OpenTX FW : Firmware BL : Bootloader, loads the FW S.Port : SmartPort, sometimes referred to as sport . FrSky \"telemetry\" protocol. The S.Port also gets used for updating FrSky receivers. OTA : Update your device Over The Air (wifi) MCU : Micro Controller Unit, generally denotes an embedded system controller as opposed to big iron cpu OSD : On Screen Display, refer to this page for instructions for setup in BF LQ : Link Quality, percentage of expected packets received. Our preferred method of measuring the quality of the control link RSSI dBm : Measure of power level measured in dBm. Basically, how strong the signal being received is RSSI : Received Signal Strength Indicator, \"arbitrary\" scaled version of RSSI dBm or LQ. Signal Health: LQI and RSSI Explained Lua : Means \"Moon\" in Portuguese. As such, Lua is the correct way to write and not all uppercase. The ExpressLRS Lua script can be installed on a OpenTX radio, to easily alter TX parameters like Packet rate, Telemetry ratio and Output power. But also shows if the radio (OpenTX) is communicating correctly with the module. ( e.g. 0:50, 0:150, 0:200 and so on.) To be continued.","title":"Glossary"},{"location":"info/glossary/#glossary","text":"Below you can find a list of terms you might not be sure about, as well as some common abbreviations: CRSF : TBS Crossfire, more specifialy in our case most often refering to the communication protocol between TX and TX module and RX and FC respectively OTX : OpenTX FW : Firmware BL : Bootloader, loads the FW S.Port : SmartPort, sometimes referred to as sport . FrSky \"telemetry\" protocol. The S.Port also gets used for updating FrSky receivers. OTA : Update your device Over The Air (wifi) MCU : Micro Controller Unit, generally denotes an embedded system controller as opposed to big iron cpu OSD : On Screen Display, refer to this page for instructions for setup in BF LQ : Link Quality, percentage of expected packets received. Our preferred method of measuring the quality of the control link RSSI dBm : Measure of power level measured in dBm. Basically, how strong the signal being received is RSSI : Received Signal Strength Indicator, \"arbitrary\" scaled version of RSSI dBm or LQ. Signal Health: LQI and RSSI Explained Lua : Means \"Moon\" in Portuguese. As such, Lua is the correct way to write and not all uppercase. The ExpressLRS Lua script can be installed on a OpenTX radio, to easily alter TX parameters like Packet rate, Telemetry ratio and Output power. But also shows if the radio (OpenTX) is communicating correctly with the module. ( e.g. 0:50, 0:150, 0:200 and so on.) To be continued.","title":"Glossary"},{"location":"info/rx-scoreboard/","text":"The RX Scoreboard is a developer / troubleshooting feature that shows the outcome of every receiver packet cycle with a single character. Enable it with -DPRINT_RX_SCOREBOARD when compiling any RX environment and connect to the debug serial UART, usually the same as the CRSF output UART for most environments. \u26a0\ufe0f For that reason, it should not be enabled during normal RC control operation since it will get mixed in with real CRSF data sent to the FC. Example 500Hz 1:32 Scoreboard \u00b6 RRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRR RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRR RRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRR._RRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRR RRRRRRRRRRRRRRTRRRRRRRRRRRRRRR_RRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRT RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRR_RRRRRRRRRRRRRRTRRRRRRRRRRRRRRR RRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRR__.RRRRRRRRRRRR RTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRR RRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRR RRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRR RRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRR RRRRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRR RRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRR RRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRR RRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRR.RRTRRRRRRRRRRRRRRRRRRRRRR RRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRR RRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRR._RRRRRRRRRRRRRRRRRRTRRRRRRRR.RRRRRRRRRRR RRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRR RRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRR RRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTR RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRR RRRRRRRRRRRRRRRTRRRRsRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR TRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRR RRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR.TRRRRRRRRRRRRRRRRRRRRRRRRRRRRR RRTRRRRRRRRRRRRRRRRRR_RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRR RRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRR RRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRR RRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRR RRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRR RRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRR._R_RRRRRRRRRRRRRRRRTRRRRRRRR.RRRRRRRRRRRRRR RRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRR Character Legend \u00b6 Character Meaning Description R Receive \u2714\ufe0f A valid RC sticks or MSP packet was received which passes all validation T Telemetry \u2714\ufe0f Telemetry was successfully transmitted s SYNC \u2714\ufe0f A valid SYNC packet was received. Sync packets come about once every 4 seconds, or more frequently around a telemetry ratio or packet rate change _ Missing \u274c No packet was received at all yet one was expected \ud83d\udc7b . CRC \u274c A packet was received but failed CRC check Name Origin \u00b6 The term scoreboard originated from an Apache (web server) feature that would display the state of every worked as a single character in a text block. Thanks to them for the feature name and the dodecatillion web pages they've enabled serving.","title":"RX Scoreboard"},{"location":"info/rx-scoreboard/#example-500hz-132-scoreboard","text":"RRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRR RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRR RRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRR._RRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRR RRRRRRRRRRRRRRTRRRRRRRRRRRRRRR_RRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRT RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRR_RRRRRRRRRRRRRRTRRRRRRRRRRRRRRR RRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRR__.RRRRRRRRRRRR RTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRR RRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRR RRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRR RRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRR RRRRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRR RRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRR RRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRR RRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRR.RRTRRRRRRRRRRRRRRRRRRRRRR RRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRR RRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRR._RRRRRRRRRRRRRRRRRRTRRRRRRRR.RRRRRRRRRRR RRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRR RRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRR RRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTR RRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRR RRRRRRRRRRRRRRRTRRRRsRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR TRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRR RRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR.TRRRRRRRRRRRRRRRRRRRRRRRRRRRRR RRTRRRRRRRRRRRRRRRRRR_RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRR RRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRR RRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRR RRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRR_RRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRR RRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRR RRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRR._R_RRRRRRRRRRRRRRRRTRRRRRRRR.RRRRRRRRRRRRRR RRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRTRRRRRR","title":"Example 500Hz 1:32 Scoreboard"},{"location":"info/rx-scoreboard/#character-legend","text":"Character Meaning Description R Receive \u2714\ufe0f A valid RC sticks or MSP packet was received which passes all validation T Telemetry \u2714\ufe0f Telemetry was successfully transmitted s SYNC \u2714\ufe0f A valid SYNC packet was received. Sync packets come about once every 4 seconds, or more frequently around a telemetry ratio or packet rate change _ Missing \u274c No packet was received at all yet one was expected \ud83d\udc7b . CRC \u274c A packet was received but failed CRC check","title":"Character Legend"},{"location":"info/rx-scoreboard/#name-origin","text":"The term scoreboard originated from an Apache (web server) feature that would display the state of every worked as a single character in a text block. Thanks to them for the feature name and the dodecatillion web pages they've enabled serving.","title":"Name Origin"},{"location":"info/signal-health/","text":"RSSI has become somewhat a generic term for how good a signal is, and every manufacturer can have their own scale, with most agreeing that \"100\" is the best, less than that is bad, and expect have RXLOSS at ???. This is an explanation of the signal metrics provided by ExpressLRS and how to understand their values. Two Types of Signal Health \u00b6 There are two main types of signal information available from ExpressLRS: RSSI and LQI RSSI - Received Signal Strength Indicator, this value indicates how loud \ud83c\udfba the reception is. RSSI must be above the sensitivity level to be understood. Units are dBm and start from 0 and go down as the volume gets lower (-130dBm hard limit). LQI - Link Quality Indicator, this value indicates how much of the conversation is being understood and ultimately all that matters. Units are percent, with 100% being every packet is received, and 0% means no packets are being received. Consider you're having a conversation in a quiet room. Your partner speaks loudly enough for you to hear, so the RSSI of their voice is above the sensitivity of your ears. You're going to understand the conversation because you're hearing every word. That's a 100% LQI-- you're receiving 100% of the words. Now imagine someone blows an air horn right in the middle of a sentence. The RSSI is still the same level, you still hear what you could make out at the same volume, you missed a word so the LQI is lower. The closer the volume of the conversation is to the background noise level in the room, the greater the chance is that you'll miss a word due to it getting mixed in with the background noise and lowering your LQI. Remember, LQI is all that matters. Your partner could shout as loud as they want but if you could hear every word anyway, the volume doesn't matter, you always heard every word. Which do I care about? \u00b6 Both really. LQI is most important because you can't fly if you're not getting packets. RSSI is important because it tells you how close you are to the radio receiver not being able to receive packets at all. I'd say if you have just one, pick LQI, because that tells you what percentage of packets are getting through and you get to make the decision if it isn't enough. What you can't tell from LQI alone is when that number is going to drop off a cliff, and it could happen extremely fast because you hit the RSSI sensitivity limit. RSSI Sensitivity Limit \u00b6 This is the lowest theoretical RSSI value that can be distinguished by the radio receiver. It is displayed in the ELRS.lua when you select the packet rate, because different packet rates and frequency bands have different sensitivity limits. Lower rates are more sensitive, -123dBm for 25Hz 915MHz up to -105dBm for 500Hz 2400MHz. This gives you the limit you know you can't fly below. RSSI Channel \u00b6 RSSI and LQI are included already in the protocol used to communicate to the flight controller, so the \"RSSI Channel\" on the Receiver tab should be set to Disabled. RSSI_ADC / \"Analog RSSI input\" on the Configuration tab should also be disabled. Available RSSI OSD Fields \u00b6 RSSI dBm - This is the true RSSI value we've talked about here, and is available on Betaflight after 4.1 (?) and iNav after 2.6 (?) Link Quality - This is LQI discussed here, and has the same version requirements. Betaflight and iNav (LQ TYPE2 option) display add the RF Mode to this as well, e.g. 7:100 means mode 7 = 500Hz and 100% LQI. RSSI Value - Or sometimes just RSSI . This is the old undefined units of Signal Strength value that everyone is used to with no idea what value is good or what value is too bad. What value you'll actually see here varies, even on ExpressLRS, and is covered in the RSSI Value OSD field section. It is not recommended to use this field unless you have to (e.g. DJI). RSSI Value OSD field \u00b6 What appears in the RSSI Value field is based on what is selected as the RSSI Channel as ExpressLRS also sends LQI and RSSI as channels (AUX11/ch15 and AUX12/ch16 respectively). It is better to use the dBm or LQ OSD fields instead of this one if you can. DJI users are forced to use this due to it being the only field supported by their OSD. Changes to RSSI Channel in Betaflight requires a reboot to take effect. Disabled is set as the \"RSSI Channel\" field in Betaflight - Displays RSSI dBm scaled as a percentage from -130dBm to 0dBm. Not recommended since what percentage of 130 is the Sensitivity Limit for your selected rate? Math! AUX11/ch15 is set as the \"RSSI Channel\" - Simply LQI although the value might be slightly off due to rounding. AUX12/ch16 is set as the \"RSSI Channel\" - Displays the RSSI dBm scaled as a percentage from the current Sensitivity Limit to -50dBm and is a decent indicator of how much range is left before the LQI cliff (0 here = Sensitivity Limit). In iNAV, the RSSI Value on the OSD is called RSSI (Signal Strength), and will always display 0. To show a filtered (by iNav) LQI in that field, set the rssi_source to protocol using the CLI with set rssi_source = PROTOCOL . What about SNR? \u00b6 Wow look at you smarty pants! SNR stands for Signal to Noise ratio and compares RSSI dBm to the RF background noise level and is in dB units (not dBm). Notice it compares the background noise level and not the Sensitivity Limit. The value is of limited usefulness because the RF chip can only approximate the noise level and can only register a value so high above it leading to this value getting clipped. Add to that, LoRa modulation can actually receive data below the noise floor to some degree, so just ignore this number really, but positive values are better. How far can I go on XmW? \u00b6 Very far? This question is usually used in place of the actual question \"Will I get good signal where I fly?\" which is impossible to answer. ExpressLRS 2.4GHz can go over 40km at 250Hz 100mW on omnidirectional antennas with excellent LQI, or it can go 400m with less stellar LQI. By far the biggest factor in determining maximum range is direct line of sight. Blocking line of sight reduces RSSI dBm. A few trees or a building isn't going to keep you from flying due to ExpressLRS's excellent sensitivity even when line of sight isn't available, but range is reduced a bit for every physical object between you and the receiver. Piloting from an elevated position can eliminate some ground obstacles and provide a measurable boost in range. The second largest factor is interference. Interference is the clobbering of our packets by outside sources, such as wifi on 2.4GHz or other ISM transmissions on 868/915MHz, and is seen as a drop in LQI well before the sensitivity limit. Increasing TX power output is usually not the solution you'd expect, where each doubling in output power only might only add 10% to the usable range due to interference. #Team868/#Team915 or #Team2.4 \u00b6 Unfortunately, there is a misconception about the 2.4GHz range thanks to other radio protocols on the market. ExpressLRS uses LoRa, which has had some amazing results on 2.4GHz. Again, 40km on 100mW 250Hz on 2.4GHz. The advantages of 2.4GHz is that the antennas are 2.5x smaller than 915MHz antennas, and there's more spectrum for ExpressLRS to hop around in, opening up the air for more pilots at once. 868/915MHz does have increased penetration and is the ultimate king of long range flying, but penetration difference may not be as great as you think. The high sensitivity of ExpressLRS receivers allows them to fly places you wouldn't dream of flying FSK-based 2.4 receivers such as FrSky ACCST/ACCESS, FlySky AFHDS2A, Spektrum DMX, or Redpine. RF noise \u00b6 We have all heard the stories of racers powering up his TBS crossfire full module at 2W and causing people to fail-safe during a race. This happens because the 868/915mhz band has limited bandwidth. The solution for this is to use a low power mode during races, so you do not blast anyone out of the sky. 2.4ghz does not have this issue. Flite Test has a world record of having 179 RC airplanes in the sky using 2.4 GHz. 2.4GHz LoRa can also handle WiFi noise very well. Studies have been conducted with the coexistence of WiFi and LoRa bands. 868/915 does not have to worry about WiFi signal but it does have to worry about cell towers and other RF noise. You are fighting against thermostats, fire systems, burglar systems and any other device running on that band.","title":"Signal Health"},{"location":"info/signal-health/#two-types-of-signal-health","text":"There are two main types of signal information available from ExpressLRS: RSSI and LQI RSSI - Received Signal Strength Indicator, this value indicates how loud \ud83c\udfba the reception is. RSSI must be above the sensitivity level to be understood. Units are dBm and start from 0 and go down as the volume gets lower (-130dBm hard limit). LQI - Link Quality Indicator, this value indicates how much of the conversation is being understood and ultimately all that matters. Units are percent, with 100% being every packet is received, and 0% means no packets are being received. Consider you're having a conversation in a quiet room. Your partner speaks loudly enough for you to hear, so the RSSI of their voice is above the sensitivity of your ears. You're going to understand the conversation because you're hearing every word. That's a 100% LQI-- you're receiving 100% of the words. Now imagine someone blows an air horn right in the middle of a sentence. The RSSI is still the same level, you still hear what you could make out at the same volume, you missed a word so the LQI is lower. The closer the volume of the conversation is to the background noise level in the room, the greater the chance is that you'll miss a word due to it getting mixed in with the background noise and lowering your LQI. Remember, LQI is all that matters. Your partner could shout as loud as they want but if you could hear every word anyway, the volume doesn't matter, you always heard every word.","title":"Two Types of Signal Health"},{"location":"info/signal-health/#which-do-i-care-about","text":"Both really. LQI is most important because you can't fly if you're not getting packets. RSSI is important because it tells you how close you are to the radio receiver not being able to receive packets at all. I'd say if you have just one, pick LQI, because that tells you what percentage of packets are getting through and you get to make the decision if it isn't enough. What you can't tell from LQI alone is when that number is going to drop off a cliff, and it could happen extremely fast because you hit the RSSI sensitivity limit.","title":"Which do I care about?"},{"location":"info/signal-health/#rssi-sensitivity-limit","text":"This is the lowest theoretical RSSI value that can be distinguished by the radio receiver. It is displayed in the ELRS.lua when you select the packet rate, because different packet rates and frequency bands have different sensitivity limits. Lower rates are more sensitive, -123dBm for 25Hz 915MHz up to -105dBm for 500Hz 2400MHz. This gives you the limit you know you can't fly below.","title":"RSSI Sensitivity Limit"},{"location":"info/signal-health/#rssi-channel","text":"RSSI and LQI are included already in the protocol used to communicate to the flight controller, so the \"RSSI Channel\" on the Receiver tab should be set to Disabled. RSSI_ADC / \"Analog RSSI input\" on the Configuration tab should also be disabled.","title":"RSSI Channel"},{"location":"info/signal-health/#available-rssi-osd-fields","text":"RSSI dBm - This is the true RSSI value we've talked about here, and is available on Betaflight after 4.1 (?) and iNav after 2.6 (?) Link Quality - This is LQI discussed here, and has the same version requirements. Betaflight and iNav (LQ TYPE2 option) display add the RF Mode to this as well, e.g. 7:100 means mode 7 = 500Hz and 100% LQI. RSSI Value - Or sometimes just RSSI . This is the old undefined units of Signal Strength value that everyone is used to with no idea what value is good or what value is too bad. What value you'll actually see here varies, even on ExpressLRS, and is covered in the RSSI Value OSD field section. It is not recommended to use this field unless you have to (e.g. DJI).","title":"Available RSSI OSD Fields"},{"location":"info/signal-health/#rssi-value-osd-field","text":"What appears in the RSSI Value field is based on what is selected as the RSSI Channel as ExpressLRS also sends LQI and RSSI as channels (AUX11/ch15 and AUX12/ch16 respectively). It is better to use the dBm or LQ OSD fields instead of this one if you can. DJI users are forced to use this due to it being the only field supported by their OSD. Changes to RSSI Channel in Betaflight requires a reboot to take effect. Disabled is set as the \"RSSI Channel\" field in Betaflight - Displays RSSI dBm scaled as a percentage from -130dBm to 0dBm. Not recommended since what percentage of 130 is the Sensitivity Limit for your selected rate? Math! AUX11/ch15 is set as the \"RSSI Channel\" - Simply LQI although the value might be slightly off due to rounding. AUX12/ch16 is set as the \"RSSI Channel\" - Displays the RSSI dBm scaled as a percentage from the current Sensitivity Limit to -50dBm and is a decent indicator of how much range is left before the LQI cliff (0 here = Sensitivity Limit). In iNAV, the RSSI Value on the OSD is called RSSI (Signal Strength), and will always display 0. To show a filtered (by iNav) LQI in that field, set the rssi_source to protocol using the CLI with set rssi_source = PROTOCOL .","title":"RSSI Value OSD field"},{"location":"info/signal-health/#what-about-snr","text":"Wow look at you smarty pants! SNR stands for Signal to Noise ratio and compares RSSI dBm to the RF background noise level and is in dB units (not dBm). Notice it compares the background noise level and not the Sensitivity Limit. The value is of limited usefulness because the RF chip can only approximate the noise level and can only register a value so high above it leading to this value getting clipped. Add to that, LoRa modulation can actually receive data below the noise floor to some degree, so just ignore this number really, but positive values are better.","title":"What about SNR?"},{"location":"info/signal-health/#how-far-can-i-go-on-xmw","text":"Very far? This question is usually used in place of the actual question \"Will I get good signal where I fly?\" which is impossible to answer. ExpressLRS 2.4GHz can go over 40km at 250Hz 100mW on omnidirectional antennas with excellent LQI, or it can go 400m with less stellar LQI. By far the biggest factor in determining maximum range is direct line of sight. Blocking line of sight reduces RSSI dBm. A few trees or a building isn't going to keep you from flying due to ExpressLRS's excellent sensitivity even when line of sight isn't available, but range is reduced a bit for every physical object between you and the receiver. Piloting from an elevated position can eliminate some ground obstacles and provide a measurable boost in range. The second largest factor is interference. Interference is the clobbering of our packets by outside sources, such as wifi on 2.4GHz or other ISM transmissions on 868/915MHz, and is seen as a drop in LQI well before the sensitivity limit. Increasing TX power output is usually not the solution you'd expect, where each doubling in output power only might only add 10% to the usable range due to interference.","title":"How far can I go on XmW?"},{"location":"info/signal-health/#team868team915-or-team24","text":"Unfortunately, there is a misconception about the 2.4GHz range thanks to other radio protocols on the market. ExpressLRS uses LoRa, which has had some amazing results on 2.4GHz. Again, 40km on 100mW 250Hz on 2.4GHz. The advantages of 2.4GHz is that the antennas are 2.5x smaller than 915MHz antennas, and there's more spectrum for ExpressLRS to hop around in, opening up the air for more pilots at once. 868/915MHz does have increased penetration and is the ultimate king of long range flying, but penetration difference may not be as great as you think. The high sensitivity of ExpressLRS receivers allows them to fly places you wouldn't dream of flying FSK-based 2.4 receivers such as FrSky ACCST/ACCESS, FlySky AFHDS2A, Spektrum DMX, or Redpine.","title":"#Team868/#Team915 or #Team2.4"},{"location":"info/signal-health/#rf-noise","text":"We have all heard the stories of racers powering up his TBS crossfire full module at 2W and causing people to fail-safe during a race. This happens because the 868/915mhz band has limited bandwidth. The solution for this is to use a low power mode during races, so you do not blast anyone out of the sky. 2.4ghz does not have this issue. Flite Test has a world record of having 179 RC airplanes in the sky using 2.4 GHz. 2.4GHz LoRa can also handle WiFi noise very well. Studies have been conducted with the coexistence of WiFi and LoRa bands. 868/915 does not have to worry about WiFi signal but it does have to worry about cell towers and other RF noise. You are fighting against thermostats, fire systems, burglar systems and any other device running on that band.","title":"RF noise"},{"location":"info/telem-bandwidth/","text":"Telemetry Burst describes the allocation of telemetry packets in ExpressLRS added in #472 . There are two types of packets, LINK and DATA. LINK is the standard link statistics and is always available, and DATA is \"Advanced Telemetry\" which is telemetry coming from the flight controller and shares bandwidth with MSP transfers. Burst mode attempts to maintain a minimum rate of LINK packets and use the rest of the available telemetry slots for DATA. The LINK rate chosen was one every 512ms, roughly 2 per second but slightly higher to allow more rates to have an additional burst packet at lower ratios. Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst) 500 1:128 256 3.9 1 78bps 78bps 500 1:64 128 7.8 3 156bps 234bps 500 1:32 64 15.6 7 312bps 547bps 500 1:16 32 31.2 15 625bps 1172bps 500 1:8 16 62.5 31 1250bps 2422bps 500 1:4 8 125.0 63 2500bps 4922bps 500 1:2 4 250.0 127 5000bps 9922bps Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst) 250 1:128 512 2.0 1 39bps 39bps 250 1:64 256 3.9 1 78bps 78bps 250 1:32 128 7.8 3 156bps 234bps 250 1:16 64 15.6 7 312bps 547bps 250 1:8 32 31.2 15 625bps 1172bps 250 1:4 16 62.5 31 1250bps 2422bps 250 1:2 8 125.0 63 2500bps 4922bps Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst) 200 1:128 640 1.6 1 31bps 31bps 200 1:64 320 3.1 1 62bps 62bps 200 1:32 160 6.2 2 125bps 167bps 200 1:16 80 12.5 5 250bps 417bps 200 1:8 40 25.0 11 500bps 917bps 200 1:4 20 50.0 24 1000bps 1920bps 200 1:2 10 100.0 50 2000bps 3922bps Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst) 150 1:128 853 1.2 1 23bps 23bps 150 1:64 426 2.3 1 47bps 47bps 150 1:32 213 4.7 1 94bps 94bps 150 1:16 106 9.4 3 188bps 281bps 150 1:8 53 18.8 8 375bps 667bps 150 1:4 26 37.5 18 750bps 1421bps 150 1:2 13 75.0 37 1500bps 2921bps Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst) 100 1:128 1280 0.8 1 16bps 16bps 100 1:64 640 1.6 1 31bps 31bps 100 1:32 320 3.1 1 62bps 62bps 100 1:16 160 6.2 2 125bps 167bps 100 1:8 80 12.5 5 250bps 417bps 100 1:4 40 25.0 11 500bps 917bps 100 1:2 20 50.0 24 1000bps 1920bps Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst) 50 1:128 2560 0.4 1 8bps 8bps 50 1:64 1280 0.8 1 16bps 16bps 50 1:32 640 1.6 1 31bps 31bps 50 1:16 320 3.1 1 62bps 62bps 50 1:8 160 6.2 2 125bps 167bps 50 1:4 80 12.5 5 250bps 417bps 50 1:2 40 25.0 11 500bps 917bps Air Rate Telem Ratio Telem Interval (ms) Packets/second Burst Count Bandwidth (no Burst) Bandwidth (Burst) 25 1:128 5120 0.2 1 4bps 4bps 25 1:64 2560 0.4 1 8bps 8bps 25 1:32 1280 0.8 1 16bps 16bps 25 1:16 640 1.6 1 31bps 31bps 25 1:8 320 3.1 1 62bps 62bps 25 1:4 160 6.2 2 125bps 167bps 25 1:2 80 12.5 5 250bps 417bps // Source code for table generator int main(void) { for (uint8_t rate=RATE_500HZ; rate<RATE_4HZ; ++rate) { uint32_t hz = RateEnumToHz((expresslrs_RFrates_e)rate); printf(\"| Air Rate | Telem Ratio | Telem Interval (ms) | Packets/second | Bandwidth (no Burst) | Bandwidth (Burst)\\n\"); if (rate == RATE_500HZ) printf(\"|---|---|---|---|---|---|\\n\"); for (uint8_t ratio=TLM_RATIO_1_128; ratio<TLM_RATIO_ENUM_MAX; ++ratio) { uint32_t tlmRatio = TLMratioEnumToValue((expresslrs_tlm_ratio_e)ratio); float telemPps = (float)hz / tlmRatio; uint32_t telemInterval = 1000 * tlmRatio / hz; uint32_t tlmBurst = TELEM_MIN_LINK_INTERVAL * hz / tlmRatio / 1000; // Reserve one slot for LINK telemetry if (tlmBurst > 1) --tlmBurst; else tlmBurst = 1; printf(\"%u | 1:%u | %u | %.1f | %u | %.0fbps | %.0fbps\\n\", hz, tlmRatio, telemInterval, telemPps, tlmBurst, telemPps*1/2*5*8, 5*8*telemPps*tlmBurst/(tlmBurst+1)); } } return 0; }","title":"Telemetry Bandwith"},{"location":"info/unit-testing/","text":"Assuming you have Visual Studio Code and platformio installed Windows Prerequisite \u00b6 Install mingw-w64 from https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe/download In the windows search bar type env and select Edit the system environment variables Click the Environment Variables... button and in the System variables section double-click Path and click New then paste C:\\Program Files (x86)\\mingw-w64\\i686-8.1.0-posix-dwarf-rt_v6-rev0\\mingw32\\bin . This path may be different on your system, but it is the path that mingw-w64 was installed to previously. Running the tests \u00b6 In VSCode with the ExpressLRS project open, click on the New Terminal button in the status bar Ensure the native platform is installed by entering pio platform install native in the terminal window. Now you can enter pio test -e native to run the tests. It also possible to use the pio module and select native/Advanced/Test in the target selection list.","title":"Unit Testing"},{"location":"info/unit-testing/#windows-prerequisite","text":"Install mingw-w64 from https://sourceforge.net/projects/mingw-w64/files/Toolchains%20targetting%20Win32/Personal%20Builds/mingw-builds/installer/mingw-w64-install.exe/download In the windows search bar type env and select Edit the system environment variables Click the Environment Variables... button and in the System variables section double-click Path and click New then paste C:\\Program Files (x86)\\mingw-w64\\i686-8.1.0-posix-dwarf-rt_v6-rev0\\mingw32\\bin . This path may be different on your system, but it is the path that mingw-w64 was installed to previously.","title":"Windows Prerequisite"},{"location":"info/unit-testing/#running-the-tests","text":"In VSCode with the ExpressLRS project open, click on the New Terminal button in the status bar Ensure the native platform is installed by entering pio platform install native in the terminal window. Now you can enter pio test -e native to run the tests. It also possible to use the pio module and select native/Advanced/Test in the target selection list.","title":"Running the tests"},{"location":"quick-start/ardupilot-setup/","text":"Ardupilot Serial Setup \u00b6 As with any serial-based receiver, you need to attach the TX/RX pads to a UART on your flight controller, then enable Serial RX in the corresponding UART in Ardupilot. In mission planner, you will need to go to the config tab -> parameter tree SERIALx_PROT = 23 (RCIN) RSSI_TYPE = 3 (ReceiverProtocol) Once you have set the parameter above, power-cycle the flight controller by disconnecting and reconnecting your battery and USB. Ardupilot should automatically run with ELRS, but if it fails, set the other parameter as below: SERIALx_PROT = 23 (RCIN) SERIALx_BAUD = 115 RC_PROT = 9 (CRSF) RSSI_TYPE = 3 (ReceiverProtocol) Ardupilot Flightmodes \u00b6 Ardupilot default flightmodes channel is channel 8, but ELRS 8 position channel is on channel 12. you will need to set your handset to use channel 12 as flightmodes and set Ardupilot parameter: FLTMODE_CH=12 Ardupilot RSSI and Link Quality \u00b6 To show RSSI (in %) set: RSSI_TYPE = 3 (ReceiverProtocol) But if you prefer to see the LQ instead of RSSI, you need to set: RSSI_TYPE = 2 (RC Channel PWM value) RSSI_CHANNEL = 15 (channel 15 is LQ) And if you prefer to see all Rfmode, LQ, and RSSI dBm simultaneously, you will need a custom firmware of Ardupilot that has a small snippet to show RFmode, LQ, and RSSI. You can get your Ardupilot .hex files for the custom firmware here: https://github.com/StonedDawg/ardupilot/tree/4.1devrssi/release Click on the FC firmware you need, and then right click on the download button and save link as. and set: RSSI_TYPE = 3 (ReceiverProtocol) This custom firmware will show the OSD LQ ELEMENT as XX.YYY (RFmode.LQ) and the OSD RSSI ELEMENT as dBm. It will also bypass the Ardupilot crossfire serial number check, that causes a notification message to keep popping up (CRSF: RFmode is x, rate is xx). Happy Flying!","title":"Ardupilot Setup"},{"location":"quick-start/ardupilot-setup/#ardupilot-serial-setup","text":"As with any serial-based receiver, you need to attach the TX/RX pads to a UART on your flight controller, then enable Serial RX in the corresponding UART in Ardupilot. In mission planner, you will need to go to the config tab -> parameter tree SERIALx_PROT = 23 (RCIN) RSSI_TYPE = 3 (ReceiverProtocol) Once you have set the parameter above, power-cycle the flight controller by disconnecting and reconnecting your battery and USB. Ardupilot should automatically run with ELRS, but if it fails, set the other parameter as below: SERIALx_PROT = 23 (RCIN) SERIALx_BAUD = 115 RC_PROT = 9 (CRSF) RSSI_TYPE = 3 (ReceiverProtocol)","title":"Ardupilot Serial Setup"},{"location":"quick-start/ardupilot-setup/#ardupilot-flightmodes","text":"Ardupilot default flightmodes channel is channel 8, but ELRS 8 position channel is on channel 12. you will need to set your handset to use channel 12 as flightmodes and set Ardupilot parameter: FLTMODE_CH=12","title":"Ardupilot Flightmodes"},{"location":"quick-start/ardupilot-setup/#ardupilot-rssi-and-link-quality","text":"To show RSSI (in %) set: RSSI_TYPE = 3 (ReceiverProtocol) But if you prefer to see the LQ instead of RSSI, you need to set: RSSI_TYPE = 2 (RC Channel PWM value) RSSI_CHANNEL = 15 (channel 15 is LQ) And if you prefer to see all Rfmode, LQ, and RSSI dBm simultaneously, you will need a custom firmware of Ardupilot that has a small snippet to show RFmode, LQ, and RSSI. You can get your Ardupilot .hex files for the custom firmware here: https://github.com/StonedDawg/ardupilot/tree/4.1devrssi/release Click on the FC firmware you need, and then right click on the download button and save link as. and set: RSSI_TYPE = 3 (ReceiverProtocol) This custom firmware will show the OSD LQ ELEMENT as XX.YYY (RFmode.LQ) and the OSD RSSI ELEMENT as dBm. It will also bypass the Ardupilot crossfire serial number check, that causes a notification message to keep popping up (CRSF: RFmode is x, rate is xx). Happy Flying!","title":"Ardupilot RSSI and Link Quality"},{"location":"quick-start/binding/","text":"Binding can be done with either a hard coded unique binding phrase or in a more traditional way where you put the receiver and transmitter into bind mode, and they link up. There is no reason to use traditional binding if you're flashing both your TX and RX firmware anyway. If you used a bind phrase in your user defines, there is no need to read this article. Proceed to the next section . If not, here is how to bind an ELRS TX and RX. Unique Phrase \u00b6 You need to have a unique binding phrase in the user_defines.txt file or entered in the \"Custom Binding Phrase\" box in the Configurator. After flashing your TX and RX, they will bind automatically. Is my binding phrase a secret? -DMY_BINDING_PHRASE=\"default ExpressLRS binding phrase\" Traditional Binding \u00b6 For traditional binding, the binding phrase must be commented out in user_defines on the RX. Power off your transmitter Plug in and unplug your receiver three times Make sure the LED is doing a quick double blink, which indicates the receiver is in bind mode Use the [BIND] button on the Lua script, which sends out a binding pulse If the receiver has a solid light, it's bound! Important: If the RX firmware has a bind phrase, the RX will never enter binding mode using the above procedure. It must be flashed without a binding phrase to do traditional binding. Why would you not use a bind phrase though if you're already having to flash the RX anyway? Connection Check \u00b6 Go to the Telemetry Page of your model setup and try to find new sensors. If the telemetry data shows up then you are connected!","title":"Binding ExpressLRS"},{"location":"quick-start/binding/#unique-phrase","text":"You need to have a unique binding phrase in the user_defines.txt file or entered in the \"Custom Binding Phrase\" box in the Configurator. After flashing your TX and RX, they will bind automatically. Is my binding phrase a secret? -DMY_BINDING_PHRASE=\"default ExpressLRS binding phrase\"","title":"Unique Phrase"},{"location":"quick-start/binding/#traditional-binding","text":"For traditional binding, the binding phrase must be commented out in user_defines on the RX. Power off your transmitter Plug in and unplug your receiver three times Make sure the LED is doing a quick double blink, which indicates the receiver is in bind mode Use the [BIND] button on the Lua script, which sends out a binding pulse If the receiver has a solid light, it's bound! Important: If the RX firmware has a bind phrase, the RX will never enter binding mode using the above procedure. It must be flashed without a binding phrase to do traditional binding. Why would you not use a bind phrase though if you're already having to flash the RX anyway?","title":"Traditional Binding"},{"location":"quick-start/binding/#connection-check","text":"Go to the Telemetry Page of your model setup and try to find new sensors. If the telemetry data shows up then you are connected!","title":"Connection Check"},{"location":"quick-start/firmware-options/","text":"This page aims to explain which options to set on the ExpressLRS Configurator for a particular Hardware. It helps guide you through which options you should enable for your purposes or which options should be left at default. Some of these options are present on both the Tx and Rx Targets. It is important that these options match to both the TX module and receiver in order for them to bind. team2400 and team900 also share a few options and some options are unique to that frequency band. Shown below are common options available on team2400 and team900 TXes respectively. Regulatory Domains \u00b6 Regulatory_Domain_AU_915 Regulatory_Domain_EU_868 Regulatory_Domain_FCC_915 Regulatory_Domain_ISM_2400 This is a relatively simple one - enable whatever regulatory domain you are in. EU 868 is compliant to the frequency but is not LBT compliant \ud83d\udc42 . Every other band is near compliant \ud83d\udc7f but may not be fully compliant for your regulatory domain. Binding Phrase \u00b6 This step is simple but important . Both the TX and RX NEED to have the same binding phrase or ExpressLRS WILL NOT WORK . Anyone using the same binding phrase as you will be able to control your model, so be unique. Set something memorable, and limit to alphanumeric phrases conforming to the Latin alphabet. Receivers flashed with firmware builds that do not have binding phrase enabled will support and require the traditional binding method . \ud83d\udcdc Performance Options \u00b6 NO_SYNC_ON_ARM no sync on arm doesn't transmit sync packets while armed. This is useful for racing as there is less time & packets wasted \ud83d\uddd1\ufe0f on sending sync packets. HOWEVER if you are doing serious long range \u26f0\ufe0f, keep this commented because in the case of a sustained failsafe, link can not be regained while armed. AUX1 is the channel ExpressLRS uses to detect \"ARMED\", and this feature assumes that a low value of the arm switch is disarmed, and a high value is armed . OpenTX can invert your switch if you prefer it to be mechanically inverted. It may be best not to enable no sync on arm when you are first setting up ExpressLRS as it can be a source of confusion. FEATURE_OPENTX_SYNC This option enables lower latency \ud83c\udfc3\u200d\u2642\ufe0f from the OpenTX radio to the TX and should be kept enabled. To get the full benefit of the option, you should be running an OpenTX version with CRSFShot or Mixer Sync enabled. USE-500HZ This enables 500Hz mode for 2.4 GHz RXes and TXes. The drawback is that you have to give up 25Hz mode to add 500Hz mode. It requires OpenTX 2.3.12 or Newer , EdgeTX or a Radio firmware that has CRSFShot or Mixer Sync. Note: Since version 1.0.0-RC9, this option is now always enabled and in turn, 25Hz has been dropped/removed. Extra Data \u00b6 HYBRID_SWITCHES_8 Changes how the AUX channels are sent over the air. The default option is Normal Mode with 8x 2-position low-latency switches. Enabling HYBRID_SWITCHES_8 changes this to 1x 2-pos + 6x 7-pos + 1x 16-pos, with only the 2-position being low-latency. In Normal Mode, all switches are sent with every packet; while in Hybrid Mode, only AUX1 is sent with every packet and the rest are rotated through. Note: The switch mode MUST match between the TX and RX . A detailed explanation of the differences between the two options can be found in the Switch Modes page. ENABLE_TELEMETRY Enable advanced telemetry support. This option must be enabled on both TX and RX . The following telemetry messages are supported: GPS BATTERY_SENSOR ATTITUDE DEVICE_INFO FLIGHT_MODE MSP_RESP Note 1 : Increase the telemetry rate with the ExpressLRS lua script. Increase the rate until the sensor lost warnings go away. It is normal to set it up to 1:16 with 200 Hz refresh rate. Note 2 : It must be enabled together with HYBRID_SWITCHES_8 . With this unchecked/disabled, you will only get the basic RC Link Telemetry like 1RRS (RSSI dbm), RQLY (LQ) etc. Tip. You can have this option enabled in the Firmware Configuration, but set TLM Ratio to OFF in the ELRS Lua Script when you don't need advanced telemetry (like when racing). Should you need the telemetry (freestyle or medium-to-long-range flying), flip TLM Ratio back to your favorite ratio, like 1:16 or 1:8. TLM_REPORT_INTERVAL_MS It makes the TX module send the telemetry data to OpenTX to the interval you set. This stops the telemetry lost warnings when running a high telemetry ratio, or low rates like 50hz. Default value is 320LU . If you want to change that you have to suffix your milliseconds value with LU . For example, in order to specify 100 ms telemetry update rate you have to enter it like this: 100LU . Typically, you want to keep 320LU value for OpenTX based radios, and 100LU for ErskyTx ones. Tip: only check this if you're changing the value. No need to enable it if you'll be using the default 320LU value Other Options \u00b6 JUST_BEEP_ONCE DISABLE_STARTUP_BEEP MY_STARTUP_MELODY=\"<music string>|<bpm>|<semitone offset>\" For TXes like the R9M, this sets if the TX only beeps one-time, not beep at all or play custom a startup song. By default it is set to play the ExpressLRS Startup Tune \ud83c\udfbc , but if you don't prefer it, or simply want to go stealthy, enable any of these options. \u2716\ufe0f For all your customization needs, use MY_STARTUP_MELODY to define your own startup melody using either the BlHeli32 syntax or RTTL. The BlHeli32 Synatax has the required parameters music string and bpm , and semitone offset is optional to transpose the entire melody up or down by the defined amount of semitones. Example BlHeli32 melodies are available on Rox Wolfs youtube channel , some experimentation may be required though. To write your own melody, this (Sheet Music 101) and this (BLHeli Piano) are useful resources. The RTTL Syntax is the same as used in old mobil phones for ringtones and some examples of it can be found here , where you can search through many existing RTTL melodies. UNLOCK_HIGHER_POWER Majority of the ExpressLRS modules maxes out at 250mW. With this option, higher power levels can be unlocked on the modules that supports it. However, it is imperative that you have taken measures to provide ample cooling to the module's internals through the use of a Fan Mod . This specifically applies to the R9M, which, from factory, supports a higher power level up to 1W; but because ExpressLRS runs at a much higher duty cycle, it taxes the circuity and thus produces heat much earlier. To keep it stable, cooling should be implemented. Without any cooling, you run the risk of ending up with a red paperweight. UART_INVERTED This only works with ESP based TXes (will not work with modules without built-in inversion/uninversion), but enables compatibility with radios that output inverted CRSF, such as the FrSky QX7, TBS Tango 2, RadioMaster TX16S. You want to keep this enabled in most of the cases. If your radio is T8SG V2 or you use Deviation firmware turn this setting off. Receiver Only Options \u00b6 Note: Configuration of the Receivers should match the configuration of the Transmitter Module for Sync/Binding to happen between devices. The explanation of the options for the Transmitter Modules also apply for the Receivers. But here's a few Receiver-specific Options you can configure: LOCK_ON_FIRST_CONNECTION RF Mode Locking - When the RX is waiting for a connection, it cycles through all available rates waiting for a connection on each one. By default, ExpressLRS will go back to this mode after a disconnect (failsafe). If LOCK_ON_FIRST_CONNECTION is used, ELRS will not cycle after a disconnect, but instead just stay on whatever rate the last connection was. This makes connection re-establishment quick, because the RX is always listening at the proper rate. This is generally what everyone wants, but there is utility in being able to switch the TX to the lowest rate to get more range to re-establish a link with a downed model, which can't happen if the RX is locked at the previous rate. When cycling through the rates, the RX starts with the fastest packet rate and works down to the slowest, then repeats. It waits PACKET_INTERVAL * PACKS_PER_HOP * HOP_COUNT * 1.1 at each rate. Example: 4ms * 4 * 80 * 1.1 = 1.408s for 250Hz. The duration is extended 10x if a valid packet is received during that time. Even with LOCK_ON_FIRST_CONNECTION, the rate can be changed by changing the TX rate using ELRS.lua while connected, or by power cycling the RX. AUTO_WIFI_ON_INTERVAL \u26a0\ufe0f Must be defined if you plan to update your RX over wifi without using a button on the RX \u26a0\ufe0f This will automatically turn the wifi \ud83d\udcf6 on for any module that has an ESP8285 on it if no TX connection is established after N seconds from boot (Factory Firmware of the HappyModel receivers set this to the previous default of 20s. RC8 has increased the interval to 30s). This enables pushing firmware updates to the RX by connecting to its wifi network and visiting http://10.0.0.1 . USE_DIVERSITY Enable antenna-switching diversity for Receivers that support it. USE_R9MM_R9MINI_SBUS This does not turn on SBUS protocol it simply changes the pin used for communication from those two side pins (A9 and A10) to use the pin labeled \"SBUS\" on the RX, which is inverted. This is useful for F4 FCs which only have an inverted receiver input UART RX. \ud83d\udd3c. This is only one way, so you lose the telemetry downlink to your radio as well as passthrough flashing. Enabling this turns on CRSF protocol output on the S.BUS \ud83d\ude8c pin on your R9MM/R9Mini. set serialrx_inverted = ON may also be needed within Betaflight \ud83d\udc1d for compatibility For a complete list of User Defines, head over to the User Defines page . Done! It's time to flash the firmware on your transmitter","title":"Firmware Options"},{"location":"quick-start/firmware-options/#regulatory-domains","text":"Regulatory_Domain_AU_915 Regulatory_Domain_EU_868 Regulatory_Domain_FCC_915 Regulatory_Domain_ISM_2400 This is a relatively simple one - enable whatever regulatory domain you are in. EU 868 is compliant to the frequency but is not LBT compliant \ud83d\udc42 . Every other band is near compliant \ud83d\udc7f but may not be fully compliant for your regulatory domain.","title":"Regulatory Domains"},{"location":"quick-start/firmware-options/#binding-phrase","text":"This step is simple but important . Both the TX and RX NEED to have the same binding phrase or ExpressLRS WILL NOT WORK . Anyone using the same binding phrase as you will be able to control your model, so be unique. Set something memorable, and limit to alphanumeric phrases conforming to the Latin alphabet. Receivers flashed with firmware builds that do not have binding phrase enabled will support and require the traditional binding method . \ud83d\udcdc","title":"Binding Phrase"},{"location":"quick-start/firmware-options/#performance-options","text":"NO_SYNC_ON_ARM no sync on arm doesn't transmit sync packets while armed. This is useful for racing as there is less time & packets wasted \ud83d\uddd1\ufe0f on sending sync packets. HOWEVER if you are doing serious long range \u26f0\ufe0f, keep this commented because in the case of a sustained failsafe, link can not be regained while armed. AUX1 is the channel ExpressLRS uses to detect \"ARMED\", and this feature assumes that a low value of the arm switch is disarmed, and a high value is armed . OpenTX can invert your switch if you prefer it to be mechanically inverted. It may be best not to enable no sync on arm when you are first setting up ExpressLRS as it can be a source of confusion. FEATURE_OPENTX_SYNC This option enables lower latency \ud83c\udfc3\u200d\u2642\ufe0f from the OpenTX radio to the TX and should be kept enabled. To get the full benefit of the option, you should be running an OpenTX version with CRSFShot or Mixer Sync enabled. USE-500HZ This enables 500Hz mode for 2.4 GHz RXes and TXes. The drawback is that you have to give up 25Hz mode to add 500Hz mode. It requires OpenTX 2.3.12 or Newer , EdgeTX or a Radio firmware that has CRSFShot or Mixer Sync. Note: Since version 1.0.0-RC9, this option is now always enabled and in turn, 25Hz has been dropped/removed.","title":"Performance Options"},{"location":"quick-start/firmware-options/#extra-data","text":"HYBRID_SWITCHES_8 Changes how the AUX channels are sent over the air. The default option is Normal Mode with 8x 2-position low-latency switches. Enabling HYBRID_SWITCHES_8 changes this to 1x 2-pos + 6x 7-pos + 1x 16-pos, with only the 2-position being low-latency. In Normal Mode, all switches are sent with every packet; while in Hybrid Mode, only AUX1 is sent with every packet and the rest are rotated through. Note: The switch mode MUST match between the TX and RX . A detailed explanation of the differences between the two options can be found in the Switch Modes page. ENABLE_TELEMETRY Enable advanced telemetry support. This option must be enabled on both TX and RX . The following telemetry messages are supported: GPS BATTERY_SENSOR ATTITUDE DEVICE_INFO FLIGHT_MODE MSP_RESP Note 1 : Increase the telemetry rate with the ExpressLRS lua script. Increase the rate until the sensor lost warnings go away. It is normal to set it up to 1:16 with 200 Hz refresh rate. Note 2 : It must be enabled together with HYBRID_SWITCHES_8 . With this unchecked/disabled, you will only get the basic RC Link Telemetry like 1RRS (RSSI dbm), RQLY (LQ) etc. Tip. You can have this option enabled in the Firmware Configuration, but set TLM Ratio to OFF in the ELRS Lua Script when you don't need advanced telemetry (like when racing). Should you need the telemetry (freestyle or medium-to-long-range flying), flip TLM Ratio back to your favorite ratio, like 1:16 or 1:8. TLM_REPORT_INTERVAL_MS It makes the TX module send the telemetry data to OpenTX to the interval you set. This stops the telemetry lost warnings when running a high telemetry ratio, or low rates like 50hz. Default value is 320LU . If you want to change that you have to suffix your milliseconds value with LU . For example, in order to specify 100 ms telemetry update rate you have to enter it like this: 100LU . Typically, you want to keep 320LU value for OpenTX based radios, and 100LU for ErskyTx ones. Tip: only check this if you're changing the value. No need to enable it if you'll be using the default 320LU value","title":"Extra Data"},{"location":"quick-start/firmware-options/#other-options","text":"JUST_BEEP_ONCE DISABLE_STARTUP_BEEP MY_STARTUP_MELODY=\"<music string>|<bpm>|<semitone offset>\" For TXes like the R9M, this sets if the TX only beeps one-time, not beep at all or play custom a startup song. By default it is set to play the ExpressLRS Startup Tune \ud83c\udfbc , but if you don't prefer it, or simply want to go stealthy, enable any of these options. \u2716\ufe0f For all your customization needs, use MY_STARTUP_MELODY to define your own startup melody using either the BlHeli32 syntax or RTTL. The BlHeli32 Synatax has the required parameters music string and bpm , and semitone offset is optional to transpose the entire melody up or down by the defined amount of semitones. Example BlHeli32 melodies are available on Rox Wolfs youtube channel , some experimentation may be required though. To write your own melody, this (Sheet Music 101) and this (BLHeli Piano) are useful resources. The RTTL Syntax is the same as used in old mobil phones for ringtones and some examples of it can be found here , where you can search through many existing RTTL melodies. UNLOCK_HIGHER_POWER Majority of the ExpressLRS modules maxes out at 250mW. With this option, higher power levels can be unlocked on the modules that supports it. However, it is imperative that you have taken measures to provide ample cooling to the module's internals through the use of a Fan Mod . This specifically applies to the R9M, which, from factory, supports a higher power level up to 1W; but because ExpressLRS runs at a much higher duty cycle, it taxes the circuity and thus produces heat much earlier. To keep it stable, cooling should be implemented. Without any cooling, you run the risk of ending up with a red paperweight. UART_INVERTED This only works with ESP based TXes (will not work with modules without built-in inversion/uninversion), but enables compatibility with radios that output inverted CRSF, such as the FrSky QX7, TBS Tango 2, RadioMaster TX16S. You want to keep this enabled in most of the cases. If your radio is T8SG V2 or you use Deviation firmware turn this setting off.","title":"Other Options"},{"location":"quick-start/firmware-options/#receiver-only-options","text":"Note: Configuration of the Receivers should match the configuration of the Transmitter Module for Sync/Binding to happen between devices. The explanation of the options for the Transmitter Modules also apply for the Receivers. But here's a few Receiver-specific Options you can configure: LOCK_ON_FIRST_CONNECTION RF Mode Locking - When the RX is waiting for a connection, it cycles through all available rates waiting for a connection on each one. By default, ExpressLRS will go back to this mode after a disconnect (failsafe). If LOCK_ON_FIRST_CONNECTION is used, ELRS will not cycle after a disconnect, but instead just stay on whatever rate the last connection was. This makes connection re-establishment quick, because the RX is always listening at the proper rate. This is generally what everyone wants, but there is utility in being able to switch the TX to the lowest rate to get more range to re-establish a link with a downed model, which can't happen if the RX is locked at the previous rate. When cycling through the rates, the RX starts with the fastest packet rate and works down to the slowest, then repeats. It waits PACKET_INTERVAL * PACKS_PER_HOP * HOP_COUNT * 1.1 at each rate. Example: 4ms * 4 * 80 * 1.1 = 1.408s for 250Hz. The duration is extended 10x if a valid packet is received during that time. Even with LOCK_ON_FIRST_CONNECTION, the rate can be changed by changing the TX rate using ELRS.lua while connected, or by power cycling the RX. AUTO_WIFI_ON_INTERVAL \u26a0\ufe0f Must be defined if you plan to update your RX over wifi without using a button on the RX \u26a0\ufe0f This will automatically turn the wifi \ud83d\udcf6 on for any module that has an ESP8285 on it if no TX connection is established after N seconds from boot (Factory Firmware of the HappyModel receivers set this to the previous default of 20s. RC8 has increased the interval to 30s). This enables pushing firmware updates to the RX by connecting to its wifi network and visiting http://10.0.0.1 . USE_DIVERSITY Enable antenna-switching diversity for Receivers that support it. USE_R9MM_R9MINI_SBUS This does not turn on SBUS protocol it simply changes the pin used for communication from those two side pins (A9 and A10) to use the pin labeled \"SBUS\" on the RX, which is inverted. This is useful for F4 FCs which only have an inverted receiver input UART RX. \ud83d\udd3c. This is only one way, so you lose the telemetry downlink to your radio as well as passthrough flashing. Enabling this turns on CRSF protocol output on the S.BUS \ud83d\ude8c pin on your R9MM/R9Mini. set serialrx_inverted = ON may also be needed within Betaflight \ud83d\udc1d for compatibility For a complete list of User Defines, head over to the User Defines page . Done! It's time to flash the firmware on your transmitter","title":"Receiver Only Options"},{"location":"quick-start/getting-started/","text":"Welcome to the ELRS Quick Start Guide! Please use the Navigation Bar at the bottom of each page for a more step-by-step approach, or use the Navigation Menu at the left to get to a Hardware-specific Guide. Longer pages have a Table of Contents menu found on the right hand side of the page. We hope these pages will help you get started with ExpressLRS and experience one of the best and innovative RC Link in the hobby.","title":"Getting Started"},{"location":"quick-start/installing-configurator/","text":"There are two ways to build & flash ExpressLRS. The recommended way is to use ExpressLRS Configurator. For advanced users who want to modify the code, you can setup the development toolchain. Configurator Setup \u00b6 Download the latest ExpressLRS Configurator application for your platform, following the instructions written by jurgelenas . The targets for each of the supported hardware can be seen on the individual device pages. Use the navigation menu on the left to get to the specific hardware page. On the next page, you will find the different Firmware Options you can set along with their explanations.","title":"Installing Configurator"},{"location":"quick-start/installing-configurator/#configurator-setup","text":"Download the latest ExpressLRS Configurator application for your platform, following the instructions written by jurgelenas . The targets for each of the supported hardware can be seen on the individual device pages. Use the navigation menu on the left to get to the specific hardware page. On the next page, you will find the different Firmware Options you can set along with their explanations.","title":"Configurator Setup"},{"location":"quick-start/pre-1stflight/","text":"Prior to your first ExpressLRS flight, you may want to do a few tweaks to your setup to ensure a fun and trouble-free ExpressLRS experience! Modes \u00b6 By default, ExpressLRS uses one-bit switches for the AUX channels. This means a three-position switch will only send two positions (fully off, or 1000, and fully on, or 2000) to Betaflight/iNav on the AUX channels. Set your modes appropriately if you are using one-bit switches, or enable HYBRID_SWITCHES_8 for expanded position options. For more information, read the switch modes page . RSSI and Link Quality \u00b6 To get RSSI and Link Quality displayed in the OSD, set RSSI Channel to \"Disabled\" in the Receiver tab of the Betaflight/iNav Configurator, and RSSI_ADC should be disabled on the Configuration tab. Both of these are the default. On the OSD menu, use the Link Quality and RSSI dBm value elements (not \"RSSI Value\"). iNav have put this in the CRSF RX Statistics section. If you wish to enable the rssi dBm warning, you'll have to change the alarm level using set osd_rssi_dbm_alarm = -100 in CLI. A sensible value is 5-10 higher than the sensitivity shown in the ELRS.lua for the packet rate (e.g. 250Hz=-108, so -103 to -98 for the alarm). If using DJI Goggles, you're required to use \"RSSI Value\" as the OSD element. Therefore you have to decide between LQ or RSSI, by selecting either AUX11 (LQ) or AUX12 (RSSI) as RSSI Channel on the Receiver tab. More information about signal metrics is found in this article on signal health . Bench Test \u00b6 Shown above is a Bench Test to determine if you're getting a good signal from your radio. This aims to provide you information on whether you should check your antennas (particularly the R9's Super 8) or you have good hardware overall. Set your ExpressLRS module to just 10mW using the Lua script. The packet rate doesn't matter much here. Put your radio 1m (3ft) from your receiver and power it up. Make sure the receiver and TX module antennas are oriented in the same way. (You might want to disconnect your vtx/air unit temporarily, put vtx on pit mode or have a fan blowing on it). Using your OSD or the Telemetry Page of your radio, take note of the RSSI dbm or the 1RSS telemetry data. On the 900Mhz hardware, a -20dbm or thereabouts is a good indication your hardware is in working order. On the 2.4Ghz hardware, around -40dbm to -30dbm should be good. If you're getting lower numbers than these, here are a few things you could check: The ExpressLRS module antenna could be loose. On some 3D printed module cases, the print may be too thick at the part where the pigtail's RP-SMA/SMA end would be attached; if so, tighten the nut on the RP-SMA/SMA to give the antenna some more space to get tightened up. The antenna pigtail may be damaged or not connected properly to the module's mainboard. On receivers using an SMD antennas, expect lower values than those equipped with wire antennas. If the receiver with the SMD antenna has heat shrink, enclosed in a whoop canopy, surrounded with carbon parts or buried inside a plane/fixed wing, expect some more attenuation of the signal. The Super 8 antenna from Frsky, which most of the R9Ms came with, are notorious for being faulty or would degrade from just a few weeks use. Replace it or as a temporary fix, solder all around the junction where the coax shielding and the RP-SMA meet. Check if there aren't any missing components in your receivers, like the RF filter (can be found near the antenna or ufl). Also check if the SMD antenna is not broken or damaged and it's soldered in properly. Some DIY modules require moving the 0 ohm resistor on the E28 from the PCB antenna side towards the UFL side. A solder bridge will work just fine as well, but make sure it is on the correct pads. Super8 Antenna's common point of failure Blackbox \u00b6 Blackbox is handy for evaluating the performance of the RF link for a flight. Set your BB to debug mode RC_SMOOTHING_RATE , which will capture the rate that Betaflight is receiving RC Packets from the RX. Telemetry \u00b6 Initially ExpressLRS had very limited telemetry support but with Version 1.0.0-RC1 this changed and full telemetry was added as optional feature . The default setting only includes the link status message that includes the RSSI and Link quality. To receive all messages the feature telemetry has to be enabled in the user defines . It's possible to flash your TX module with telemetry support enabled and use it with a RX without telemetry enabled . So you can flash certain receivers with telemetry support and others without it and use it with the same TX module. The RX transmits a subset of telemetry it receives from the flight controller. Disabling certain messages only works if the flight controller firmware does support it. For Betaflight this is possible with the telemetry_disabled_* cli settings: # Disable Attitude telemetry item set telemetry_disabled_pitch = ON set telemetry_disabled_roll = ON set telemetry_disabled_heading = ON # Disable Battery telemetry item set telemetry_disabled_voltage = ON set telemetry_disabled_current = ON set telemetry_disabled_fuel = ON # Disable GPS telemetry item set telemetry_disabled_altitude = ON set telemetry_disabled_lat_long = ON set telemetry_disabled_ground_speed = ON set telemetry_disabled_heading = ON # Disable Flight Mode telemetry item (BF >4.2.9) set telemetry_disabled_mode = ON Since telemetry messages are sent with low priority it takes some time to transmit the data. The telemetry rate in the lua settings script controls how often a telemetry message should be sent. So a ratio of 1:2 means that every second message is a telemetry message, so the telemetry data is transferred very fast. A ratio 1:64 means that only one of 64 messages is a telemetry message and so the transfer happens much slower. The refresh rate also impacts the transfer speed. 50 Hz is slower compared to 200 Hz. So if you need fast a fast telemetry update rate choose high refresh rate, and a ratio that favors telemetry messages e.g. 200 Hz and 1:16 usually works good. For detailed information on telemetry bandwidth at different rates and ratios, see this page on telemetry bandwidth . To finish the telemetry setup open the telemetry page on your transmitter and select \"Discover new sensors\" and wait for the list to fill. You will notice that there is a * sign for each row. This star indicates that this telemetry sensor was just updated. If you see a row that does not change, and the name of the row is in square brackets it means that this sensor was not updated for some time. The first values (including RSSI and link quality) should always be updated (flashing stars). If this does not happen multiple times per second the transmitter will issue a \"telemetry warning\". To prevent this warning use the setting TLM_REPORT_INTERVAL_MS. It should look like this (and if it does not there is something wrong with your setup): The remaining values are updated at a different rate (depending on refresh rate and tlm ratio). So if you use 50 Hz and 1:64 it will happen really slow, and the update takes multiple seconds for each sensor: If you use 200Hz and 1:2 tlm ratio the stars will not even blink because the update happens so fast: MSP \u00b6 To configure betaflight from your transmitter it's possible to use the betaflight lua scripts. This requires the telemetry feature enabled for the RX+TX. If the telemetry page of OpenTx does not show regular updates for all sensors the LUA script will also not work. Mavlink is not supported and currently not planned to be added. To get a responsive UI configure ExpressLRS for fast data transfer so make sure to use something like 200Hz/500Hz with 1:2 tlm and a serial baud rate of 400000 . Currently MSP is limited to 50Hz on 115200 Baud and does not work with 500 Hz refresh rate. The initial VTX tables download does take long - but is cached after that. If you get a \"retrying\" message while saving changes it means that the lua script did not receive a response fast enough. But the change usually still goes through so try reloading the page to check if the change was saved. With the recommended settings this does not happen but with slower settings it could happen. Done. Go Fly!","title":"Pre-first Flight Checks"},{"location":"quick-start/pre-1stflight/#modes","text":"By default, ExpressLRS uses one-bit switches for the AUX channels. This means a three-position switch will only send two positions (fully off, or 1000, and fully on, or 2000) to Betaflight/iNav on the AUX channels. Set your modes appropriately if you are using one-bit switches, or enable HYBRID_SWITCHES_8 for expanded position options. For more information, read the switch modes page .","title":"Modes"},{"location":"quick-start/pre-1stflight/#rssi-and-link-quality","text":"To get RSSI and Link Quality displayed in the OSD, set RSSI Channel to \"Disabled\" in the Receiver tab of the Betaflight/iNav Configurator, and RSSI_ADC should be disabled on the Configuration tab. Both of these are the default. On the OSD menu, use the Link Quality and RSSI dBm value elements (not \"RSSI Value\"). iNav have put this in the CRSF RX Statistics section. If you wish to enable the rssi dBm warning, you'll have to change the alarm level using set osd_rssi_dbm_alarm = -100 in CLI. A sensible value is 5-10 higher than the sensitivity shown in the ELRS.lua for the packet rate (e.g. 250Hz=-108, so -103 to -98 for the alarm). If using DJI Goggles, you're required to use \"RSSI Value\" as the OSD element. Therefore you have to decide between LQ or RSSI, by selecting either AUX11 (LQ) or AUX12 (RSSI) as RSSI Channel on the Receiver tab. More information about signal metrics is found in this article on signal health .","title":"RSSI and Link Quality"},{"location":"quick-start/pre-1stflight/#bench-test","text":"Shown above is a Bench Test to determine if you're getting a good signal from your radio. This aims to provide you information on whether you should check your antennas (particularly the R9's Super 8) or you have good hardware overall. Set your ExpressLRS module to just 10mW using the Lua script. The packet rate doesn't matter much here. Put your radio 1m (3ft) from your receiver and power it up. Make sure the receiver and TX module antennas are oriented in the same way. (You might want to disconnect your vtx/air unit temporarily, put vtx on pit mode or have a fan blowing on it). Using your OSD or the Telemetry Page of your radio, take note of the RSSI dbm or the 1RSS telemetry data. On the 900Mhz hardware, a -20dbm or thereabouts is a good indication your hardware is in working order. On the 2.4Ghz hardware, around -40dbm to -30dbm should be good. If you're getting lower numbers than these, here are a few things you could check: The ExpressLRS module antenna could be loose. On some 3D printed module cases, the print may be too thick at the part where the pigtail's RP-SMA/SMA end would be attached; if so, tighten the nut on the RP-SMA/SMA to give the antenna some more space to get tightened up. The antenna pigtail may be damaged or not connected properly to the module's mainboard. On receivers using an SMD antennas, expect lower values than those equipped with wire antennas. If the receiver with the SMD antenna has heat shrink, enclosed in a whoop canopy, surrounded with carbon parts or buried inside a plane/fixed wing, expect some more attenuation of the signal. The Super 8 antenna from Frsky, which most of the R9Ms came with, are notorious for being faulty or would degrade from just a few weeks use. Replace it or as a temporary fix, solder all around the junction where the coax shielding and the RP-SMA meet. Check if there aren't any missing components in your receivers, like the RF filter (can be found near the antenna or ufl). Also check if the SMD antenna is not broken or damaged and it's soldered in properly. Some DIY modules require moving the 0 ohm resistor on the E28 from the PCB antenna side towards the UFL side. A solder bridge will work just fine as well, but make sure it is on the correct pads. Super8 Antenna's common point of failure","title":"Bench Test"},{"location":"quick-start/pre-1stflight/#blackbox","text":"Blackbox is handy for evaluating the performance of the RF link for a flight. Set your BB to debug mode RC_SMOOTHING_RATE , which will capture the rate that Betaflight is receiving RC Packets from the RX.","title":"Blackbox"},{"location":"quick-start/pre-1stflight/#telemetry","text":"Initially ExpressLRS had very limited telemetry support but with Version 1.0.0-RC1 this changed and full telemetry was added as optional feature . The default setting only includes the link status message that includes the RSSI and Link quality. To receive all messages the feature telemetry has to be enabled in the user defines . It's possible to flash your TX module with telemetry support enabled and use it with a RX without telemetry enabled . So you can flash certain receivers with telemetry support and others without it and use it with the same TX module. The RX transmits a subset of telemetry it receives from the flight controller. Disabling certain messages only works if the flight controller firmware does support it. For Betaflight this is possible with the telemetry_disabled_* cli settings: # Disable Attitude telemetry item set telemetry_disabled_pitch = ON set telemetry_disabled_roll = ON set telemetry_disabled_heading = ON # Disable Battery telemetry item set telemetry_disabled_voltage = ON set telemetry_disabled_current = ON set telemetry_disabled_fuel = ON # Disable GPS telemetry item set telemetry_disabled_altitude = ON set telemetry_disabled_lat_long = ON set telemetry_disabled_ground_speed = ON set telemetry_disabled_heading = ON # Disable Flight Mode telemetry item (BF >4.2.9) set telemetry_disabled_mode = ON Since telemetry messages are sent with low priority it takes some time to transmit the data. The telemetry rate in the lua settings script controls how often a telemetry message should be sent. So a ratio of 1:2 means that every second message is a telemetry message, so the telemetry data is transferred very fast. A ratio 1:64 means that only one of 64 messages is a telemetry message and so the transfer happens much slower. The refresh rate also impacts the transfer speed. 50 Hz is slower compared to 200 Hz. So if you need fast a fast telemetry update rate choose high refresh rate, and a ratio that favors telemetry messages e.g. 200 Hz and 1:16 usually works good. For detailed information on telemetry bandwidth at different rates and ratios, see this page on telemetry bandwidth . To finish the telemetry setup open the telemetry page on your transmitter and select \"Discover new sensors\" and wait for the list to fill. You will notice that there is a * sign for each row. This star indicates that this telemetry sensor was just updated. If you see a row that does not change, and the name of the row is in square brackets it means that this sensor was not updated for some time. The first values (including RSSI and link quality) should always be updated (flashing stars). If this does not happen multiple times per second the transmitter will issue a \"telemetry warning\". To prevent this warning use the setting TLM_REPORT_INTERVAL_MS. It should look like this (and if it does not there is something wrong with your setup): The remaining values are updated at a different rate (depending on refresh rate and tlm ratio). So if you use 50 Hz and 1:64 it will happen really slow, and the update takes multiple seconds for each sensor: If you use 200Hz and 1:2 tlm ratio the stars will not even blink because the update happens so fast:","title":"Telemetry"},{"location":"quick-start/pre-1stflight/#msp","text":"To configure betaflight from your transmitter it's possible to use the betaflight lua scripts. This requires the telemetry feature enabled for the RX+TX. If the telemetry page of OpenTx does not show regular updates for all sensors the LUA script will also not work. Mavlink is not supported and currently not planned to be added. To get a responsive UI configure ExpressLRS for fast data transfer so make sure to use something like 200Hz/500Hz with 1:2 tlm and a serial baud rate of 400000 . Currently MSP is limited to 50Hz on 115200 Baud and does not work with 500 Hz refresh rate. The initial VTX tables download does take long - but is cached after that. If you get a \"retrying\" message while saving changes it means that the lua script did not receive a response fast enough. But the change usually still goes through so try reloading the page to check if the change was saved. With the recommended settings this does not happen but with slower settings it could happen. Done. Go Fly!","title":"MSP"},{"location":"quick-start/rx-betafpv2400/","text":"Flashing via Passthrough \u00b6 Target: BETAFPV_2400_RX_via_BetaflightPassthrough Make sure you have wired your receiver properly. Rx pad on the Receiver wired up to a Tx pad on the FC, and the Tx pad on the Receiver wired up to an Rx pad on the FC. Also make sure you have setup your FC firmware to use CRSF Protocol, and that the UART is not inverted or running in half duplex. If the receiver gets powered up when you connect the FC to USB, you will need to Press and Hold the button on the receiver, connect USB and let go of the button once the LED stopped blinking and goes SOLID. If the receiver needs a LiPo attached to get powered up, then Press and Hold the button on the receiver, attach a LiPo, then let go once the LED in the receiver stopped blinking and goes SOLID. Then connect your FC to USB. These procedures will not be needed in subsequent passthrough flashing. This is only needed on the first time you'd update the receiver from its factory firmware. Select the corresponding target in the ExpressLRS Configurator, set your Firmware Options and then click Build and Flash . For first time flashing/updating, it would normally take a while. A Success message will be shown once the process is complete. Flashing via WiFi \u00b6 Target: BETAFPV_2400_RX_via_WIFI With the receiver wired properly to your FC, select the correct target and set the Firmware Options in the ExpressLRS Configurator. Build the firmware. Once done, it should open a new window where the firmware.bin is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver. Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using AUTO_WIFI_ON_INTERVAL ), it should blink fast indicating it's on Wifi Hotspot Mode. Connect to the Wifi Network the receiver has created. It should be named something like ExpressLRS RX with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1 ). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver firmware.bin is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the Browse or Choose File button). Click on the Update button and the firmware file will be uploaded and the update process should commence. A white page should load momentarily with the message Update Success! Rebooting... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options). Flashing via FTDI \u00b6 Target: BETAFPV_2400_RX_via_UART Wire the receiver into the FTDI, with TX on receiver connected to the Rx on the FTDI, and RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid. Select the target and set your Firmware Options and once done, click on Build and Flash .","title":"Flashing BetaFPV Nano 2.4G"},{"location":"quick-start/rx-betafpv2400/#flashing-via-passthrough","text":"Target: BETAFPV_2400_RX_via_BetaflightPassthrough Make sure you have wired your receiver properly. Rx pad on the Receiver wired up to a Tx pad on the FC, and the Tx pad on the Receiver wired up to an Rx pad on the FC. Also make sure you have setup your FC firmware to use CRSF Protocol, and that the UART is not inverted or running in half duplex. If the receiver gets powered up when you connect the FC to USB, you will need to Press and Hold the button on the receiver, connect USB and let go of the button once the LED stopped blinking and goes SOLID. If the receiver needs a LiPo attached to get powered up, then Press and Hold the button on the receiver, attach a LiPo, then let go once the LED in the receiver stopped blinking and goes SOLID. Then connect your FC to USB. These procedures will not be needed in subsequent passthrough flashing. This is only needed on the first time you'd update the receiver from its factory firmware. Select the corresponding target in the ExpressLRS Configurator, set your Firmware Options and then click Build and Flash . For first time flashing/updating, it would normally take a while. A Success message will be shown once the process is complete.","title":"Flashing via Passthrough"},{"location":"quick-start/rx-betafpv2400/#flashing-via-wifi","text":"Target: BETAFPV_2400_RX_via_WIFI With the receiver wired properly to your FC, select the correct target and set the Firmware Options in the ExpressLRS Configurator. Build the firmware. Once done, it should open a new window where the firmware.bin is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver. Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using AUTO_WIFI_ON_INTERVAL ), it should blink fast indicating it's on Wifi Hotspot Mode. Connect to the Wifi Network the receiver has created. It should be named something like ExpressLRS RX with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1 ). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver firmware.bin is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the Browse or Choose File button). Click on the Update button and the firmware file will be uploaded and the update process should commence. A white page should load momentarily with the message Update Success! Rebooting... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options).","title":"Flashing via WiFi"},{"location":"quick-start/rx-betafpv2400/#flashing-via-ftdi","text":"Target: BETAFPV_2400_RX_via_UART Wire the receiver into the FTDI, with TX on receiver connected to the Rx on the FTDI, and RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid. Select the target and set your Firmware Options and once done, click on Build and Flash .","title":"Flashing via FTDI"},{"location":"quick-start/rx-betafpv900/","text":"Flashing via Passthrough \u00b6 Target: BETAFPV_900_RX_via_BetaflightPassthrough Make sure you have wired your receiver properly. Rx pad on the Receiver wired up to a Tx pad on the FC, and the Tx pad on the Receiver wired up to an Rx pad on the FC. Also make sure you have setup your FC firmware to use CRSF Protocol, and that the UART is not inverted or running in half duplex. If the receiver gets powered up when you connect the FC to USB, you will need to Press and Hold the button on the receiver, connect USB and let go of the button once the LED stopped blinking and goes SOLID. If the receiver needs a LiPo attached to get powered up, then Press and Hold the button on the receiver, attach a LiPo, then let go once the LED in the receiver stopped blinking and goes SOLID. Then connect your FC to USB. These procedures will not be needed in subsequent passthrough flashing. This is only needed on the first time you'd update the receiver from its factory firmware. Select the corresponding target in the ExpressLRS Configurator, set your Firmware Options and then click Build and Flash . For first time flashing/updating, it would normally take a while. A Success message will be shown once the process is complete. Flashing via WiFi \u00b6 Target: BETAFPV_900_RX_via_WIFI With the receiver wired properly to your FC, select the correct target and set the Firmware Options in the ExpressLRS Configurator. Build the firmware. Once done, it should open a new window where the firmware.bin is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver. Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using AUTO_WIFI_ON_INTERVAL ), it should blink fast indicating it's on Wifi Hotspot Mode. Connect to the Wifi Network the receiver has created. It should be named something like ExpressLRS RX with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1 ). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver firmware.bin is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the Browse or Choose File button). Click on the Update button and the firmware file will be uploaded and the update process should commence. A white page should load momentarily with the message Update Success! Rebooting... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options). Flashing via FTDI \u00b6 Target: BETAFPV_900_RX_via_UART Wire the receiver into the FTDI, with TX on receiver connected to the Rx on the FTDI, and RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid. Select the target and set your Firmware Options and once done, click on Build and Flash .","title":"Flashing BetaFPV Nano 900Mhz"},{"location":"quick-start/rx-betafpv900/#flashing-via-passthrough","text":"Target: BETAFPV_900_RX_via_BetaflightPassthrough Make sure you have wired your receiver properly. Rx pad on the Receiver wired up to a Tx pad on the FC, and the Tx pad on the Receiver wired up to an Rx pad on the FC. Also make sure you have setup your FC firmware to use CRSF Protocol, and that the UART is not inverted or running in half duplex. If the receiver gets powered up when you connect the FC to USB, you will need to Press and Hold the button on the receiver, connect USB and let go of the button once the LED stopped blinking and goes SOLID. If the receiver needs a LiPo attached to get powered up, then Press and Hold the button on the receiver, attach a LiPo, then let go once the LED in the receiver stopped blinking and goes SOLID. Then connect your FC to USB. These procedures will not be needed in subsequent passthrough flashing. This is only needed on the first time you'd update the receiver from its factory firmware. Select the corresponding target in the ExpressLRS Configurator, set your Firmware Options and then click Build and Flash . For first time flashing/updating, it would normally take a while. A Success message will be shown once the process is complete.","title":"Flashing via Passthrough"},{"location":"quick-start/rx-betafpv900/#flashing-via-wifi","text":"Target: BETAFPV_900_RX_via_WIFI With the receiver wired properly to your FC, select the correct target and set the Firmware Options in the ExpressLRS Configurator. Build the firmware. Once done, it should open a new window where the firmware.bin is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver. Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using AUTO_WIFI_ON_INTERVAL ), it should blink fast indicating it's on Wifi Hotspot Mode. Connect to the Wifi Network the receiver has created. It should be named something like ExpressLRS RX with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1 ). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver firmware.bin is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the Browse or Choose File button). Click on the Update button and the firmware file will be uploaded and the update process should commence. A white page should load momentarily with the message Update Success! Rebooting... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options).","title":"Flashing via WiFi"},{"location":"quick-start/rx-betafpv900/#flashing-via-ftdi","text":"Target: BETAFPV_900_RX_via_UART Wire the receiver into the FTDI, with TX on receiver connected to the Rx on the FTDI, and RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid. Select the target and set your Firmware Options and once done, click on Build and Flash .","title":"Flashing via FTDI"},{"location":"quick-start/rx-bootloader/","text":"R9mm/mini, R9mx, R9Slim+ \u00b6 This guide applies for the R9mm, R9mini, R9mx, R9Slim+, R9Slim+ OTA, if you have a OpenTX transmitter with a SmartPort output, you can flash your RXes bootloader. Download the bootloader .frk file for your respective receiver. The files are as follows: R9mm/mini: r9mm_elrs_bl.frk (14kb) or r9mm_no_btn_elrs_bl.frk (14kb) (no_btn bootloader is only used if your bind/boot button on the receiver is faulty or has gone bad, and is indicated by both LEDs (red and green) being constantly illuminated.) R9mx: r9mx_elrs_bl.frk (20kb) R9Slim+ (ACCST): r9slim_plus_elrs_bl.frk (14kb) R9Slim+ (ACCESS/OTA): r9slim_plus_ota_elrs_bl.frk (18kb) Copy the relevant file to your handset's SD card (You can put it inside /FIRMWARE folder for easy access). Wire the receiver to your radio's Smart Port, as shown: Next, flash the .frk via the S.port flashing option in OpenTX . (It helps if the External RF module is set to PPM mode.) Navigate in OpenTX to the TOOLS menu (hold SYS button) Page to the SD-HC CARD page, then the FIRMWARE folder Flash the frk file by holding OK and selecting \"Flash external module\" Unplug the receiver, and your bootloader is flashed. Troubleshooting No Sync \u00b6 Setting the External RF module to PPM mode helps. Check if the receiver has its LED lit up or if it's powered. Check whether you've set your Max Bauds to 115200 , especially if you're using a QX7 or an X9D (on OneBit Firmwares or EdgeTX). If so, put it back to 400k and try again. You can now proceed to the next step!","title":"Flashing Bootloader"},{"location":"quick-start/rx-bootloader/#r9mmmini-r9mx-r9slim","text":"This guide applies for the R9mm, R9mini, R9mx, R9Slim+, R9Slim+ OTA, if you have a OpenTX transmitter with a SmartPort output, you can flash your RXes bootloader. Download the bootloader .frk file for your respective receiver. The files are as follows: R9mm/mini: r9mm_elrs_bl.frk (14kb) or r9mm_no_btn_elrs_bl.frk (14kb) (no_btn bootloader is only used if your bind/boot button on the receiver is faulty or has gone bad, and is indicated by both LEDs (red and green) being constantly illuminated.) R9mx: r9mx_elrs_bl.frk (20kb) R9Slim+ (ACCST): r9slim_plus_elrs_bl.frk (14kb) R9Slim+ (ACCESS/OTA): r9slim_plus_ota_elrs_bl.frk (18kb) Copy the relevant file to your handset's SD card (You can put it inside /FIRMWARE folder for easy access). Wire the receiver to your radio's Smart Port, as shown: Next, flash the .frk via the S.port flashing option in OpenTX . (It helps if the External RF module is set to PPM mode.) Navigate in OpenTX to the TOOLS menu (hold SYS button) Page to the SD-HC CARD page, then the FIRMWARE folder Flash the frk file by holding OK and selecting \"Flash external module\" Unplug the receiver, and your bootloader is flashed.","title":"R9mm/mini, R9mx, R9Slim+"},{"location":"quick-start/rx-bootloader/#troubleshooting-no-sync","text":"Setting the External RF module to PPM mode helps. Check if the receiver has its LED lit up or if it's powered. Check whether you've set your Max Bauds to 115200 , especially if you're using a QX7 or an X9D (on OneBit Firmwares or EdgeTX). If so, put it back to 400k and try again. You can now proceed to the next step!","title":"Troubleshooting No Sync"},{"location":"quick-start/rx-diyreceivers/","text":"Valid Targets: DIY_2400_RX_ESP8285_SX1280_via_BetaflightPassthrough DIY_2400_RX_ESP8285_SX1280_via_UART DIY_2400_RX_ESP8285_SX1280_via_WIFI DIY_2400_RX_STM32_CCG_Nano_v0_5_via_BetaflightPassthrough DIY_2400_RX_STM32_CCG_Nano_v0_5_via_STLINK","title":"Flashing DIY 2400RX"},{"location":"quick-start/rx-diyreceivers900/","text":"Valid Targets: DIY_900_RX_ESP8285_SX127x_via_BetaflightPassthrough DIY_900_RX_ESP8285_SX127x_via_UART","title":"Flashing DIY 900RX"},{"location":"quick-start/rx-fcprep/","text":"Wiring your Receiver \u00b6 R9MM/mini, R9mx, R9Slim+ \u00b6 Note: This will be the same wiring you'll use for flying and the subsequent firmware updates (via Passthrough). Forget the factory wiring guide! After you've flashed the bootloader and wired your receiver as above, proceed to configure up your flight controller as shown below . Note: R9 Slim requires flashing via STLink first. Passthrough should work for updates. Happymodel EP1, EP2, PP \u00b6 Labels show the receiver pinouts and not to which pads to connect them (in case of the RX and Tx pads). As we're dealing with UART connection, Rx on receiver goes to a TX pad in the FC, and Tx on Receiver goes to an uninverted Rx pad on the FC. There are certain FCs that puts their Receiver UART's RX pads Low, which in turn, puts the EP-based (e.g. EP1 and EP2) receivers to Bootloader mode unintentionally. One remedy is to wire them into a different UART, or wire a pull-up resistor (300-1k ohm) into the RX pad (FC Rx pad -> Resistor -> 3v3 pad). Also of note is that the EP receivers require their Boot pads (see figure above) be bridged on first time Passthrough Flash from their factory firmwares. After the first passthrough flashing, the bridge needs to be removed, and is no longer needed for subsequent passthrough flashing. Flashing via Wifi doesn't need the Boot Pads bridged. Moreover, if it is bridged, the receiver will stay in bootloader mode and won't activate the wifi hotspot. Connect your FC to USB and configure your FC firmware as below . Happymodel ES900RX \u00b6 Shown above is the pinouts for the ES900RX receivers. Connect Rx to a Tx pad on the FC and Tx to an Rx pad on the FC. Additionally, the Boot Pads, encircled in the photo above, needs to be bridged in the first-time passthrough flash from the factory firmware. As this is an ESP-based receiver, be aware that there are certain FCs that puts their Receiver UART's RX pads Low, which in turn, puts the receiver to Bootloader mode unintentionally. One remedy is to wire them into a different UART, or wire a pull-up resistor (300-1k ohm) into the RX pad (FC Rx pad -> Resistor -> 3v3 pad). Should you be updating via Wifi, the bridging of the boot pads is not needed. Connect your FC to USB and configure your FC firmware as shown below . Happymodel ES915/868RX (Discontinued) \u00b6 Labels in the receiver show the pinouts. Connect Rx to a Tx pad in the FC and the Tx to an Rx pad in the FC. Of course, don't forget to connect VCC to a 5V pad, and GND to a GND pad on the FC. Connect your FC to USB and configure your FC firmware as shown below . NamimnoRC Voyager & Flash \u00b6 Namimno Voyager ExpressLRS Receiver Namimno Flash ExpressLRS Receiver Labels in the receiver show the pinouts. Connect Rx to a Tx pad in the FC and the Tx to an Rx pad in the FC. Of course, don't forget to connect VCC to a 5V pad, and GND to a GND pad on the FC. Connect your FC to USB and configure your FC firmware as shown below . BetaFPV Receivers \u00b6 BetaFPV 900MHz ExpressLRS Receiver BetaFPV 2.4GHz ExpressLRS Receiver Shown above are the pinouts and various components of the receivers. Connect Rx to a Tx pad on the FC and Tx to an Rx pad on the FC. Don't forget to also wire up 5v(VCC) and Gnd. Updating via WiFi is supported by these receivers. Connect your FC to USB and configure your FC firmware as shown below . Serial RX Setup \u00b6 Once wired up to our Flight Controller, we need to setup the UART for Serial RX. In the example below, the Receiver is wired to a Tx1/Rx1 (UART1) Pad, and so the Serial RX column should be activated on UART1. Protocol \u00b6 Similar to your OpenTX Radio, we are using the CRSF protocol between the receiver and the FC firmware (Betaflight/iNav/emuflight), so on the \"Configuration\" tab, you need to select \"Serial-based receiver\" on the \"Receiver\" panel, and select \"CRSF\" as the protocol. Telemetry is optional here and will reduce your stick update rate due to those transmit slots being used for telemetry. Inversion (Software & Hardware) and Duplex Modes \u00b6 The CRSF Protocol requires a full UART pair, uninverted and in full-duplex mode. Using the CLI, check if serialrx_inverted is OFF and serialrx_halfduplex is OFF . To do this, simply type get serialrx in the CLI to see the settings for both at the same time. You can use set serialrx_inverted=off or set serialrx_halfduplex=off to turn them off respectively. Don't forget to also type in save after the change. You can't use an RX pad that is shared to an SBUS pad, unless you remove the inversion or reroute the line (by bridging pads in the FC although not all FC have this). The easiest way to determine which UART can be used with ExpressLRS is to check which UART the manufacturer suggests you wire a Crossfire/Ghost receiver to. Use the Navigation Menu to proceed to the Flashing Guides for these Receivers (under the section Flashing Receivers ).","title":"Preparing for Passthrough Flashing"},{"location":"quick-start/rx-fcprep/#wiring-your-receiver","text":"","title":"Wiring your Receiver"},{"location":"quick-start/rx-fcprep/#r9mmmini-r9mx-r9slim","text":"Note: This will be the same wiring you'll use for flying and the subsequent firmware updates (via Passthrough). Forget the factory wiring guide! After you've flashed the bootloader and wired your receiver as above, proceed to configure up your flight controller as shown below . Note: R9 Slim requires flashing via STLink first. Passthrough should work for updates.","title":"R9MM/mini, R9mx, R9Slim+"},{"location":"quick-start/rx-fcprep/#happymodel-ep1-ep2-pp","text":"Labels show the receiver pinouts and not to which pads to connect them (in case of the RX and Tx pads). As we're dealing with UART connection, Rx on receiver goes to a TX pad in the FC, and Tx on Receiver goes to an uninverted Rx pad on the FC. There are certain FCs that puts their Receiver UART's RX pads Low, which in turn, puts the EP-based (e.g. EP1 and EP2) receivers to Bootloader mode unintentionally. One remedy is to wire them into a different UART, or wire a pull-up resistor (300-1k ohm) into the RX pad (FC Rx pad -> Resistor -> 3v3 pad). Also of note is that the EP receivers require their Boot pads (see figure above) be bridged on first time Passthrough Flash from their factory firmwares. After the first passthrough flashing, the bridge needs to be removed, and is no longer needed for subsequent passthrough flashing. Flashing via Wifi doesn't need the Boot Pads bridged. Moreover, if it is bridged, the receiver will stay in bootloader mode and won't activate the wifi hotspot. Connect your FC to USB and configure your FC firmware as below .","title":"Happymodel EP1, EP2, PP"},{"location":"quick-start/rx-fcprep/#happymodel-es900rx","text":"Shown above is the pinouts for the ES900RX receivers. Connect Rx to a Tx pad on the FC and Tx to an Rx pad on the FC. Additionally, the Boot Pads, encircled in the photo above, needs to be bridged in the first-time passthrough flash from the factory firmware. As this is an ESP-based receiver, be aware that there are certain FCs that puts their Receiver UART's RX pads Low, which in turn, puts the receiver to Bootloader mode unintentionally. One remedy is to wire them into a different UART, or wire a pull-up resistor (300-1k ohm) into the RX pad (FC Rx pad -> Resistor -> 3v3 pad). Should you be updating via Wifi, the bridging of the boot pads is not needed. Connect your FC to USB and configure your FC firmware as shown below .","title":"Happymodel ES900RX"},{"location":"quick-start/rx-fcprep/#happymodel-es915868rx-discontinued","text":"Labels in the receiver show the pinouts. Connect Rx to a Tx pad in the FC and the Tx to an Rx pad in the FC. Of course, don't forget to connect VCC to a 5V pad, and GND to a GND pad on the FC. Connect your FC to USB and configure your FC firmware as shown below .","title":"Happymodel ES915/868RX (Discontinued)"},{"location":"quick-start/rx-fcprep/#namimnorc-voyager-flash","text":"Namimno Voyager ExpressLRS Receiver Namimno Flash ExpressLRS Receiver Labels in the receiver show the pinouts. Connect Rx to a Tx pad in the FC and the Tx to an Rx pad in the FC. Of course, don't forget to connect VCC to a 5V pad, and GND to a GND pad on the FC. Connect your FC to USB and configure your FC firmware as shown below .","title":"NamimnoRC Voyager &amp; Flash"},{"location":"quick-start/rx-fcprep/#betafpv-receivers","text":"BetaFPV 900MHz ExpressLRS Receiver BetaFPV 2.4GHz ExpressLRS Receiver Shown above are the pinouts and various components of the receivers. Connect Rx to a Tx pad on the FC and Tx to an Rx pad on the FC. Don't forget to also wire up 5v(VCC) and Gnd. Updating via WiFi is supported by these receivers. Connect your FC to USB and configure your FC firmware as shown below .","title":"BetaFPV Receivers"},{"location":"quick-start/rx-fcprep/#serial-rx-setup","text":"Once wired up to our Flight Controller, we need to setup the UART for Serial RX. In the example below, the Receiver is wired to a Tx1/Rx1 (UART1) Pad, and so the Serial RX column should be activated on UART1.","title":"Serial RX Setup"},{"location":"quick-start/rx-fcprep/#protocol","text":"Similar to your OpenTX Radio, we are using the CRSF protocol between the receiver and the FC firmware (Betaflight/iNav/emuflight), so on the \"Configuration\" tab, you need to select \"Serial-based receiver\" on the \"Receiver\" panel, and select \"CRSF\" as the protocol. Telemetry is optional here and will reduce your stick update rate due to those transmit slots being used for telemetry.","title":"Protocol"},{"location":"quick-start/rx-fcprep/#inversion-software-hardware-and-duplex-modes","text":"The CRSF Protocol requires a full UART pair, uninverted and in full-duplex mode. Using the CLI, check if serialrx_inverted is OFF and serialrx_halfduplex is OFF . To do this, simply type get serialrx in the CLI to see the settings for both at the same time. You can use set serialrx_inverted=off or set serialrx_halfduplex=off to turn them off respectively. Don't forget to also type in save after the change. You can't use an RX pad that is shared to an SBUS pad, unless you remove the inversion or reroute the line (by bridging pads in the FC although not all FC have this). The easiest way to determine which UART can be used with ExpressLRS is to check which UART the manufacturer suggests you wire a Crossfire/Ghost receiver to. Use the Navigation Menu to proceed to the Flashing Guides for these Receivers (under the section Flashing Receivers ).","title":"Inversion (Software &amp; Hardware) and Duplex Modes"},{"location":"quick-start/rx-flash2400/","text":"Check your Target \u00b6 Because of the massive shortage of STM32 Chips, there are more ESP8285 based RXes on the market. These support WiFi updating, and can be easily distinguished with a few tricks. The simplest way to tell is if on the rear of the RX (the side without the U.fl/SMD antenna) there is a large white component with the label RainSun (pictured below). If this is not there, you have an STM32 based target, if it is you have an _ESP_ target, and can update using Wifi! Betaflight Passthrough \u00b6 Targets: NamimnoRC_FLASH_2400_ESP_RX_via_BetaflightPassthrough NamimnoRC_FLASH_2400_RX_via_BetaflightPassthrough Once wired properly to your FC, connect USB. Did your receiver powered up too (with both LEDs lit)? If so, disconnect USB, hold the bind button on your receiver, and reconnect to USB. The LED should start alternating between the Green and Red LEDs. Once it's alternating, you can then let go of the Bind Button. If your receiver didn't get powered from USB, have a lipo ready and continue with the next steps. On the ExpressLRS Configurator, with your Options set, click on Build & Flash . Like on the TX module, it will take a while on the first time. Watch out for the Passthrough Init stage. This stage will check your FC Configuration for the Serial RX UART (Software Inversion via \"set serialrx_inverted\" and Half Duplex mode via \"set serialrx_halfduplex\" will be checked; both should be off.) Once Retry... lines appear, connect a LiPo if your receiver isn't powered by the USB (i.e. power up your receiver and FC). On subsequent flash, you can have the LiPo plugged in and receiver powered up from the start. Wait for this process to finish. It's done once the \"Success\" prompt is shown. Wifi Updating (ESP Only - Recommended) \u00b6 Target: NamimnoRC_FLASH_2400_ESP_RX_via_WIFI With the receiver wired properly to your FC, select the right target and set your Firmware Options in the ExpressLRS Configurator. Build the firmware. Once done, it should open a new window where the firmware.bin is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver. Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using AUTO_WIFI_ON_INTERVAL ), it should blink fast indicating it's on Wifi Hotspot Mode. Connect to the Wifi Network the receiver has created. It should be named something like ExpressLRS RX with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1 ). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver firmware.bin is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the Browse or Choose File button). Click on the Update button and the firmware file will be uploaded and the update process should commence. A white page should load momentarily with the message Update Success! Rebooting... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options). UART Updating (ESP Only) \u00b6 Target: NamimnoRC_FLASH_2400_ESP_RX_via_UART Wire the receiver into the FTDI, with the TX on receiver connected to the Rx on the FTDI, and the RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid. Select the target and set your Firmware Options and once done, click on Build and Flash . STLink Updating (STM32 Only) \u00b6 Target: NamimnoRC_FLASH_2400_RX_via_STLINK The units provided to the documentation team did not have STM32 chips due to the chip shortage, however, the following should apply. Wire CLK, 3v3, GND and DIO to the recievers STLink pins. Select the target and set your Firmware Options and once done, click on Build and Flash .","title":"Flashing NamimnoRC Flash"},{"location":"quick-start/rx-flash2400/#check-your-target","text":"Because of the massive shortage of STM32 Chips, there are more ESP8285 based RXes on the market. These support WiFi updating, and can be easily distinguished with a few tricks. The simplest way to tell is if on the rear of the RX (the side without the U.fl/SMD antenna) there is a large white component with the label RainSun (pictured below). If this is not there, you have an STM32 based target, if it is you have an _ESP_ target, and can update using Wifi!","title":"Check your Target"},{"location":"quick-start/rx-flash2400/#betaflight-passthrough","text":"Targets: NamimnoRC_FLASH_2400_ESP_RX_via_BetaflightPassthrough NamimnoRC_FLASH_2400_RX_via_BetaflightPassthrough Once wired properly to your FC, connect USB. Did your receiver powered up too (with both LEDs lit)? If so, disconnect USB, hold the bind button on your receiver, and reconnect to USB. The LED should start alternating between the Green and Red LEDs. Once it's alternating, you can then let go of the Bind Button. If your receiver didn't get powered from USB, have a lipo ready and continue with the next steps. On the ExpressLRS Configurator, with your Options set, click on Build & Flash . Like on the TX module, it will take a while on the first time. Watch out for the Passthrough Init stage. This stage will check your FC Configuration for the Serial RX UART (Software Inversion via \"set serialrx_inverted\" and Half Duplex mode via \"set serialrx_halfduplex\" will be checked; both should be off.) Once Retry... lines appear, connect a LiPo if your receiver isn't powered by the USB (i.e. power up your receiver and FC). On subsequent flash, you can have the LiPo plugged in and receiver powered up from the start. Wait for this process to finish. It's done once the \"Success\" prompt is shown.","title":"Betaflight Passthrough"},{"location":"quick-start/rx-flash2400/#wifi-updating-esp-only-recommended","text":"Target: NamimnoRC_FLASH_2400_ESP_RX_via_WIFI With the receiver wired properly to your FC, select the right target and set your Firmware Options in the ExpressLRS Configurator. Build the firmware. Once done, it should open a new window where the firmware.bin is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver. Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using AUTO_WIFI_ON_INTERVAL ), it should blink fast indicating it's on Wifi Hotspot Mode. Connect to the Wifi Network the receiver has created. It should be named something like ExpressLRS RX with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1 ). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver firmware.bin is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the Browse or Choose File button). Click on the Update button and the firmware file will be uploaded and the update process should commence. A white page should load momentarily with the message Update Success! Rebooting... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options).","title":"Wifi Updating (ESP Only - Recommended)"},{"location":"quick-start/rx-flash2400/#uart-updating-esp-only","text":"Target: NamimnoRC_FLASH_2400_ESP_RX_via_UART Wire the receiver into the FTDI, with the TX on receiver connected to the Rx on the FTDI, and the RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid. Select the target and set your Firmware Options and once done, click on Build and Flash .","title":"UART Updating (ESP Only)"},{"location":"quick-start/rx-flash2400/#stlink-updating-stm32-only","text":"Target: NamimnoRC_FLASH_2400_RX_via_STLINK The units provided to the documentation team did not have STM32 chips due to the chip shortage, however, the following should apply. Wire CLK, 3v3, GND and DIO to the recievers STLink pins. Select the target and set your Firmware Options and once done, click on Build and Flash .","title":"STLink Updating (STM32 Only)"},{"location":"quick-start/rx-ghost2400/","text":"Flashing Ghost Atto/Zepto RX's \u00b6 Target: GHOST_ATTO_2400_RX_via_STLINK Flashing the Ghost RX's is currently a 1 WAY flash once you flash ExpressLRS to these RX's you will not be able to use them with Ghost TX. You will need a StLink V2 to flash the RX's Wire 3.3v , GND , CLK , and DIO to their respective pins on the RX from the StLink. Select the GHOST_ATTO_2400_via_STLINK target. Set your Firmware Options and click on Build and Flash . Connect your receiver to your Flight Controller as normal (i.e. Rx to Tx, and Tx to Rx); Subsequent Firmware Updates can now be done using via_BetaflightPassthrough target.","title":"Flashing Ghost Receiver"},{"location":"quick-start/rx-ghost2400/#flashing-ghost-attozepto-rxs","text":"Target: GHOST_ATTO_2400_RX_via_STLINK Flashing the Ghost RX's is currently a 1 WAY flash once you flash ExpressLRS to these RX's you will not be able to use them with Ghost TX. You will need a StLink V2 to flash the RX's Wire 3.3v , GND , CLK , and DIO to their respective pins on the RX from the StLink. Select the GHOST_ATTO_2400_via_STLINK target. Set your Firmware Options and click on Build and Flash . Connect your receiver to your Flight Controller as normal (i.e. Rx to Tx, and Tx to Rx); Subsequent Firmware Updates can now be done using via_BetaflightPassthrough target.","title":"Flashing Ghost Atto/Zepto RX's"},{"location":"quick-start/rx-hmep2400/","text":"Flashing via Wifi \u00b6 (Recommended as first-flash method) Target: HappyModel_EP_2400_RX_via_WIFI Wire up your receiver to a free UART on your Flight Controller. Wire TX on receiver to an RX pad on the FC, and the RX on receiver to a TX pad on the FC in the same UART. Wire 5v and Gnd as normal (5v to a 5v pad on FC and Gnd to a Gnd pad on the FC). Note: There are Flight Controllers that will pull the RX pads LOW which will put the ESP-based receivers into Bootloader Mode unintentionally. A solid LED light on these receivers even with the TX module off is a sign they are in Bootloader Mode. If this is the case, rewire the receiver to a different UART. Build the firmware using the ExpressLRS Configurator using the correct Target and options . Once done, it should open a new window where the firmware.bin is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver. Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if receiver gets powered from USB via a 4v5 pad). Receiver's LED will blink slow at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using AUTO_WIFI_ON_INTERVAL ), it should blink fast indicating it's on Wifi Hotspot Mode. Connect to the Wifi Network the receiver has created. It should be named something like ExpressLRS RX with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1 ). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver firmware.bin is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the Browse or Choose File button). Click on Update button and the firmware file will be uploaded and the update process should commence. A white page should load momentarily with the message Update Success! Rebooting... . You should wait until the LED on the receiver starts to blink slowly (waiting some more will put the receiver into WiFi mode). Power cycle your FC and turn on your radio to verify you are bound and have connection. Flashing via Passthrough \u00b6 Target: HappyModel_EP_2400_RX_via_BetaflightPassthrough Wire up your receiver to a free uart in your Flight Controller. Wire TX on receiver to an RX pad on the FC, and the RX on receiver to a TX pad on the FC in the same UART. Wire 5v and Gnd as normal (5v to a 5v pad on FC and Gnd to a Gnd pad on the FC). You will need to bridge the Boot pads on the receiver the first time you'll be updating via this method. The image above shows where the Boot pads are. A solid LED indicates the receiver is in Bootloader mode when the TX module is OFF (Solid LED also indicates Radio+module & Receiver is bound and has connection). Note: if you haven't bridged the Boot pads but the receiver has solid LED light, your FC is probably pulling the current UART's RX pad LOW which will interfere with the normal and passthrough flashing of this receiver. Find another UART and wire your receiver there instead Bridging the Boot pads is no longer needed past 1.0.0-RC6. Power your FC with a LiPo, or if receiver is powered via USB (receiver is connected to a 4v5 pad), connect the FC to your USB port. Using the ExpressLRS Configurator, with the correct Target selected and options set, click on Build & Flash . Wait for the process to finish and you should be greeted with the \"Success\" banner. Unplug USB and LiPo, and removed the solder on the bridged Boot pads. You no longer need it (past 1.0.0-RC6). Power your TX Module and then your FC to verify you are bound and has connection. Flashing via FTDI \u00b6 Target: HappyModel_EP_2400_RX_via_UART Wire the receiver into the FTDI, with TX on receiver connected to the Rx on the FTDI, and RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Short the boot pad while powering the RX on, and release - the LED should now be solid. Select the target and set your Firmware Options and once done, click on Build and Flash .","title":"Flashing Happymodel EPs"},{"location":"quick-start/rx-hmep2400/#flashing-via-wifi","text":"(Recommended as first-flash method) Target: HappyModel_EP_2400_RX_via_WIFI Wire up your receiver to a free UART on your Flight Controller. Wire TX on receiver to an RX pad on the FC, and the RX on receiver to a TX pad on the FC in the same UART. Wire 5v and Gnd as normal (5v to a 5v pad on FC and Gnd to a Gnd pad on the FC). Note: There are Flight Controllers that will pull the RX pads LOW which will put the ESP-based receivers into Bootloader Mode unintentionally. A solid LED light on these receivers even with the TX module off is a sign they are in Bootloader Mode. If this is the case, rewire the receiver to a different UART. Build the firmware using the ExpressLRS Configurator using the correct Target and options . Once done, it should open a new window where the firmware.bin is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver. Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if receiver gets powered from USB via a 4v5 pad). Receiver's LED will blink slow at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using AUTO_WIFI_ON_INTERVAL ), it should blink fast indicating it's on Wifi Hotspot Mode. Connect to the Wifi Network the receiver has created. It should be named something like ExpressLRS RX with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1 ). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver firmware.bin is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the Browse or Choose File button). Click on Update button and the firmware file will be uploaded and the update process should commence. A white page should load momentarily with the message Update Success! Rebooting... . You should wait until the LED on the receiver starts to blink slowly (waiting some more will put the receiver into WiFi mode). Power cycle your FC and turn on your radio to verify you are bound and have connection.","title":"Flashing via Wifi"},{"location":"quick-start/rx-hmep2400/#flashing-via-passthrough","text":"Target: HappyModel_EP_2400_RX_via_BetaflightPassthrough Wire up your receiver to a free uart in your Flight Controller. Wire TX on receiver to an RX pad on the FC, and the RX on receiver to a TX pad on the FC in the same UART. Wire 5v and Gnd as normal (5v to a 5v pad on FC and Gnd to a Gnd pad on the FC). You will need to bridge the Boot pads on the receiver the first time you'll be updating via this method. The image above shows where the Boot pads are. A solid LED indicates the receiver is in Bootloader mode when the TX module is OFF (Solid LED also indicates Radio+module & Receiver is bound and has connection). Note: if you haven't bridged the Boot pads but the receiver has solid LED light, your FC is probably pulling the current UART's RX pad LOW which will interfere with the normal and passthrough flashing of this receiver. Find another UART and wire your receiver there instead Bridging the Boot pads is no longer needed past 1.0.0-RC6. Power your FC with a LiPo, or if receiver is powered via USB (receiver is connected to a 4v5 pad), connect the FC to your USB port. Using the ExpressLRS Configurator, with the correct Target selected and options set, click on Build & Flash . Wait for the process to finish and you should be greeted with the \"Success\" banner. Unplug USB and LiPo, and removed the solder on the bridged Boot pads. You no longer need it (past 1.0.0-RC6). Power your TX Module and then your FC to verify you are bound and has connection.","title":"Flashing via Passthrough"},{"location":"quick-start/rx-hmep2400/#flashing-via-ftdi","text":"Target: HappyModel_EP_2400_RX_via_UART Wire the receiver into the FTDI, with TX on receiver connected to the Rx on the FTDI, and RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Short the boot pad while powering the RX on, and release - the LED should now be solid. Select the target and set your Firmware Options and once done, click on Build and Flash .","title":"Flashing via FTDI"},{"location":"quick-start/rx-hmes900/","text":"ES900RX \u00b6 Flashing via Passthrough \u00b6 Target: HappyModel_RX_ES900RX_via_BetaflightPassthrough With the receiver wired properly to your FC, select the right target and set your Firmware Options in the ExpressLRS Configurator, then click on Build and Flash . First time Compile naturally takes a while but if you do the prep work properly, you'll be greeted with the Success message soon enough! Flashing via Wifi \u00b6 With the receiver wired properly to your FC, select the right target and set your Firmware Options in the ExpressLRS Configurator. Build the firmware. Once done, it should open a new window where the firmware.bin is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver. Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using AUTO_WIFI_ON_INTERVAL ), it should blink fast indicating it's on Wifi Hotspot Mode. Connect to the Wifi Network the receiver has created. It should be named something like ExpressLRS RX with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1 ). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver firmware.bin is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the Browse or Choose File button). Click on the Update button and the firmware file will be uploaded and the update process should commence. A white page should load momentarily with the message Update Success! Rebooting... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options). ES915/868RX (Discontinued) \u00b6 Flashing via Passthrough \u00b6 Target: HappyModel_RX_ES915RX_via_BetaflightPassthrough Once wired properly to your FC, connect USB. Did your receiver powered up too (with both LEDs lit)? If so, disconnect USB, hold the bind button on your receiver, and reconnect to USB. The LED should start alternating between the Green and Red LEDs. Once it's alternating, you can then let go of the Bind Button. If your receiver didn't get powered from USB, have a lipo ready and continue with the next steps. On the ExpressLRS Configurator, with your Options set, click on Build & Flash . Like on the TX module, it will take a while on the first time. Watch out for the Passthrough Init stage. This stage will check your FC Configuration for the Serial RX UART (Software Inversion via \"set serialrx_inverted\" and Half Duplex mode via \"set serialrx_halfduplex\" will be checked; both should be off.) Once Retry... lines appear, connect a LiPo if your receiver isn't powered by the USB (i.e. power up your receiver and FC). On subsequent flash, you can have the LiPo plugged in and receiver powered up from the start. Wait for this process to finish. It's done once the \"Success\" prompt is shown. Flashing via STLink \u00b6 Target: HappyModel_RX_ES915RX_via_STLINK Wire up your receiver to your STLink, shown here . Using the correct target specific for your receiver, set your Firmware Options and hit Build & Flash on the ExpressLRS Configurator. Once done, wire your receiver to your Flight Controller. Passthrough flashing can now be used for updating the receiver.","title":"Flashing Happymodel ES900RX"},{"location":"quick-start/rx-hmes900/#es900rx","text":"","title":"ES900RX"},{"location":"quick-start/rx-hmes900/#flashing-via-passthrough","text":"Target: HappyModel_RX_ES900RX_via_BetaflightPassthrough With the receiver wired properly to your FC, select the right target and set your Firmware Options in the ExpressLRS Configurator, then click on Build and Flash . First time Compile naturally takes a while but if you do the prep work properly, you'll be greeted with the Success message soon enough!","title":"Flashing via Passthrough"},{"location":"quick-start/rx-hmes900/#flashing-via-wifi","text":"With the receiver wired properly to your FC, select the right target and set your Firmware Options in the ExpressLRS Configurator. Build the firmware. Once done, it should open a new window where the firmware.bin is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver. Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using AUTO_WIFI_ON_INTERVAL ), it should blink fast indicating it's on Wifi Hotspot Mode. Connect to the Wifi Network the receiver has created. It should be named something like ExpressLRS RX with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1 ). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver firmware.bin is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the Browse or Choose File button). Click on the Update button and the firmware file will be uploaded and the update process should commence. A white page should load momentarily with the message Update Success! Rebooting... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options).","title":"Flashing via Wifi"},{"location":"quick-start/rx-hmes900/#es915868rx-discontinued","text":"","title":"ES915/868RX (Discontinued)"},{"location":"quick-start/rx-hmes900/#flashing-via-passthrough_1","text":"Target: HappyModel_RX_ES915RX_via_BetaflightPassthrough Once wired properly to your FC, connect USB. Did your receiver powered up too (with both LEDs lit)? If so, disconnect USB, hold the bind button on your receiver, and reconnect to USB. The LED should start alternating between the Green and Red LEDs. Once it's alternating, you can then let go of the Bind Button. If your receiver didn't get powered from USB, have a lipo ready and continue with the next steps. On the ExpressLRS Configurator, with your Options set, click on Build & Flash . Like on the TX module, it will take a while on the first time. Watch out for the Passthrough Init stage. This stage will check your FC Configuration for the Serial RX UART (Software Inversion via \"set serialrx_inverted\" and Half Duplex mode via \"set serialrx_halfduplex\" will be checked; both should be off.) Once Retry... lines appear, connect a LiPo if your receiver isn't powered by the USB (i.e. power up your receiver and FC). On subsequent flash, you can have the LiPo plugged in and receiver powered up from the start. Wait for this process to finish. It's done once the \"Success\" prompt is shown.","title":"Flashing via Passthrough"},{"location":"quick-start/rx-hmes900/#flashing-via-stlink","text":"Target: HappyModel_RX_ES915RX_via_STLINK Wire up your receiver to your STLink, shown here . Using the correct target specific for your receiver, set your Firmware Options and hit Build & Flash on the ExpressLRS Configurator. Once done, wire your receiver to your Flight Controller. Passthrough flashing can now be used for updating the receiver.","title":"Flashing via STLink"},{"location":"quick-start/rx-hmpp2400/","text":"Flashing via Passthrough \u00b6 Target: HappyModel_PP_2400_RX_via_BetaflightPassthrough The PP receivers do not have Wifi, and so, it can only be updated via Passthrough. Follow the same wiring as that of the EP receivers shown here . The PP has a silkscreened \"RT5G\" on one of its side indicating the order of the pads, with R = Rx, T = Tx, 5 = 5v and G = Gnd, respectively. Connect the Rx pad to a Tx pad on the FC, and the Tx pad to an RX pad on the FC, with 5v and Gnd to their usual connections. The PP doesn't have a Boot pad either so there's no need to bridge any pads. Once wired, power up your FC by connecting a LiPo or, if the receiver is getting powered via USB, connect your USB cable to a vacant port. Using the ExpressLRS Configurator, with the correct Target selected and options set, hit Build & Flash . Wait a bit for the process to finish and you should see a \"Success\" banner. Power-cycle the FC and verify receiver connects to the Tx module (power up the Tx first, then the Receiver).","title":"Flashing Happymodel PP"},{"location":"quick-start/rx-hmpp2400/#flashing-via-passthrough","text":"Target: HappyModel_PP_2400_RX_via_BetaflightPassthrough The PP receivers do not have Wifi, and so, it can only be updated via Passthrough. Follow the same wiring as that of the EP receivers shown here . The PP has a silkscreened \"RT5G\" on one of its side indicating the order of the pads, with R = Rx, T = Tx, 5 = 5v and G = Gnd, respectively. Connect the Rx pad to a Tx pad on the FC, and the Tx pad to an RX pad on the FC, with 5v and Gnd to their usual connections. The PP doesn't have a Boot pad either so there's no need to bridge any pads. Once wired, power up your FC by connecting a LiPo or, if the receiver is getting powered via USB, connect your USB cable to a vacant port. Using the ExpressLRS Configurator, with the correct Target selected and options set, hit Build & Flash . Wait a bit for the process to finish and you should see a \"Success\" banner. Power-cycle the FC and verify receiver connects to the Tx module (power up the Tx first, then the Receiver).","title":"Flashing via Passthrough"},{"location":"quick-start/rx-jumper900/","text":"Targets: Jumper_RX_R900MINI_via_STLINK Jumper_RX_R900MINI_via_BetaflightPassthrough Disable 'Readout Protection'. To do this download the ST-LINK Utility and follow this quick how to video . Or alternatively under linux you can use OpenOCD . Using the correct target specific for your receiver, hit Build & Flash . After the flash is successful, desolder the STLink and connect RX2 and TX2 (you will need to solder on the STM32 pins, see picture) to a flight controller and setting up the receiver with the CRSF serial protocol, the Jumper_RX_R900MINI_via_BetaflightPassthrough target may now be used for future firmware.","title":"Flashing Jumper R9 Mini"},{"location":"quick-start/rx-r9receivers/","text":"FrSky RXes \u00b6 Note: This will be the same wiring you'll use for flying and the next firmware updates (via Passthrough). Forget the factory wiring guide! Passthrough Flashing (works with Betaflight, iNav) \u00b6 Valid Targets: Frsky_RX_R9MM_R9MINI_via_BetaflightPassthrough Frsky_RX_R9MX_via_BetaflightPassthrough Frsky_RX_R9SLIM_via_BetaflightPassthrough Frsky_RX_R9SLIMPLUS_via_BetaflightPassthrough Frsky_RX_R9SLIMPLUS_OTA_via_BetaflightPassthrough Make sure the correct Bootloader has been flashed to the receiver prior to wiring it up to your flight controller. Using the wiring guide above, find a free, uninverted UART in your FC. You can use your FC's wiring guide for a Crossfire or Ghost receiver. Once wired to your FC, connect USB. Did your receiver powered up too (with both LEDs lit)? If so, disconnect USB, hold the bind button on your receiver, and reconnect to USB. The LED should start alternating between the Green and Red LEDs. Once it's alternating, you can then let go of the Bind Button. If your receiver didn't get powered from USB, have a lipo ready and continue with the next steps. On the ExpressLRS Configurator, with your Options set, click on Build & Flash . Like on the TX module, it will take a while on the first time. Watch out for the Passthrough Init stage. This stage will check your FC Configuration for the Serial RX UART (Software Inversion via \"set serialrx_inverted\" and Half Duplex mode via \"set serialrx_halfduplex\" will be checked; both should be off.) Once Retry... lines appear, connect a LiPo if your receiver isn't powered by the USB (i.e. power up your FC and receiver). On subsequent flash, you can have the LiPo plugged in and receiver powered up from the start prior to connecting the USB. Wait for this process to finish. It's done once the \"Success\" prompt is shown. Flashing via STLink (only recommended as last resort) \u00b6 Valid Targets: Frsky_RX_R9MM_R9MINI_via_STLINK Frsky_RX_R9MX_via_STLINK Frsky_RX_R9SLIM_via_STLINK Frsky_RX_R9SLIMPLUS_via_STLINK Frsky_RX_R9SLIMPLUS_OTA_via_STLINK This method is irreversible. It will remove the ability to reflash back to Frsky firmware. You have been warned! Make sure your STLink dongle is properly recognized by your System as such (Drivers are installed, etc.). Disable 'Readout Protection'. To do this download the ST-LINK Utility and follow this quick how to video . Or alternatively under linux you can use OpenOCD . After doing so, Disconnect from STLink Utility. Using the correct target specific for your receiver, set your Firmware Options and hit Build & Flash on the ExpressLRS Configurator. Once done, wire your receiver to your Flight Controller. Passthrough flashing can now be used for updating the receiver.","title":"Flashing Frsky R9 Receivers"},{"location":"quick-start/rx-r9receivers/#frsky-rxes","text":"Note: This will be the same wiring you'll use for flying and the next firmware updates (via Passthrough). Forget the factory wiring guide!","title":"FrSky RXes"},{"location":"quick-start/rx-r9receivers/#passthrough-flashing-works-with-betaflight-inav","text":"Valid Targets: Frsky_RX_R9MM_R9MINI_via_BetaflightPassthrough Frsky_RX_R9MX_via_BetaflightPassthrough Frsky_RX_R9SLIM_via_BetaflightPassthrough Frsky_RX_R9SLIMPLUS_via_BetaflightPassthrough Frsky_RX_R9SLIMPLUS_OTA_via_BetaflightPassthrough Make sure the correct Bootloader has been flashed to the receiver prior to wiring it up to your flight controller. Using the wiring guide above, find a free, uninverted UART in your FC. You can use your FC's wiring guide for a Crossfire or Ghost receiver. Once wired to your FC, connect USB. Did your receiver powered up too (with both LEDs lit)? If so, disconnect USB, hold the bind button on your receiver, and reconnect to USB. The LED should start alternating between the Green and Red LEDs. Once it's alternating, you can then let go of the Bind Button. If your receiver didn't get powered from USB, have a lipo ready and continue with the next steps. On the ExpressLRS Configurator, with your Options set, click on Build & Flash . Like on the TX module, it will take a while on the first time. Watch out for the Passthrough Init stage. This stage will check your FC Configuration for the Serial RX UART (Software Inversion via \"set serialrx_inverted\" and Half Duplex mode via \"set serialrx_halfduplex\" will be checked; both should be off.) Once Retry... lines appear, connect a LiPo if your receiver isn't powered by the USB (i.e. power up your FC and receiver). On subsequent flash, you can have the LiPo plugged in and receiver powered up from the start prior to connecting the USB. Wait for this process to finish. It's done once the \"Success\" prompt is shown.","title":"Passthrough Flashing (works with Betaflight, iNav)"},{"location":"quick-start/rx-r9receivers/#flashing-via-stlink-only-recommended-as-last-resort","text":"Valid Targets: Frsky_RX_R9MM_R9MINI_via_STLINK Frsky_RX_R9MX_via_STLINK Frsky_RX_R9SLIM_via_STLINK Frsky_RX_R9SLIMPLUS_via_STLINK Frsky_RX_R9SLIMPLUS_OTA_via_STLINK This method is irreversible. It will remove the ability to reflash back to Frsky firmware. You have been warned! Make sure your STLink dongle is properly recognized by your System as such (Drivers are installed, etc.). Disable 'Readout Protection'. To do this download the ST-LINK Utility and follow this quick how to video . Or alternatively under linux you can use OpenOCD . After doing so, Disconnect from STLink Utility. Using the correct target specific for your receiver, set your Firmware Options and hit Build & Flash on the ExpressLRS Configurator. Once done, wire your receiver to your Flight Controller. Passthrough flashing can now be used for updating the receiver.","title":"Flashing via STLink (only recommended as last resort)"},{"location":"quick-start/rx-siyiFRmini/","text":"Targets: FM30_RX_MINI_via_STLINK (First-time Flash) FM30_RX_MINI_via_BetaflightPassthrough (Updates) The STLink solderpads on the FRmini RX are very tiny and very close together. The picture below is very enlarged. Solder 5 (preferable Silicon) wires to the GND-RST-VDD-CLK-DIO pads. Solder the open ends to a female 2.54 mm pin connector. (Use 3.3V NOT 5V ). Using the correct target specific for your receiver, set your firmware options and hit Build & Flash on the ExpressLRS Configurator. Once done, wire your receiver to your Flight Controller. Passthrough flashing can now be used for updating the receiver. The wiring is show below, where the FC TX goes to RX2 and the FC RX goes to TX2. Thank you to @JupaCreations","title":"Flashing Siyi FR Mini"},{"location":"quick-start/rx-stlink/","text":"Disable readout protection as shown in this video: R9MM/Mini \u00b6 Connect the STLink V2 into the pads shown below: 3v3 , GND , C = CLK and D = DIO . R9MX \u00b6 Connect the STLink V2 into the pads shown below: 3v3 , GND , C = CLK and D = DIO . R9Slim \u00b6 This RX requires an StLink v2 to be flashed. Wire up the RX to the STLink using 3v3 , GND , CLK and DIO . Wiring the R9 Slim+ for STLink flashing will be the same Jumper R900 Mini \u00b6 This also requires an STLink, so the wiring is as follows: Wire + = 3v3 , - = GND , C = CLK and D = DIO to their respective pins on the RX from the StLink. Because those pins are so small one option is to only solder a wire on the CLK and DIO then power it with the 5v pin with an external power source. ES915RX (Discontinued) \u00b6 Connect your STLink into GND , DIO , CLK , 3V3 of the receiver. These pads are marked clearly as in the image above. Use the Navigation Menu to proceed to the Flashing Guides for these Receivers (under the section Flashing Receivers ).","title":"Preparing for STLink Flashing"},{"location":"quick-start/rx-stlink/#r9mmmini","text":"Connect the STLink V2 into the pads shown below: 3v3 , GND , C = CLK and D = DIO .","title":"R9MM/Mini"},{"location":"quick-start/rx-stlink/#r9mx","text":"Connect the STLink V2 into the pads shown below: 3v3 , GND , C = CLK and D = DIO .","title":"R9MX"},{"location":"quick-start/rx-stlink/#r9slim","text":"This RX requires an StLink v2 to be flashed. Wire up the RX to the STLink using 3v3 , GND , CLK and DIO . Wiring the R9 Slim+ for STLink flashing will be the same","title":"R9Slim"},{"location":"quick-start/rx-stlink/#jumper-r900-mini","text":"This also requires an STLink, so the wiring is as follows: Wire + = 3v3 , - = GND , C = CLK and D = DIO to their respective pins on the RX from the StLink. Because those pins are so small one option is to only solder a wire on the CLK and DIO then power it with the 5v pin with an external power source.","title":"Jumper R900 Mini"},{"location":"quick-start/rx-stlink/#es915rx-discontinued","text":"Connect your STLink into GND , DIO , CLK , 3V3 of the receiver. These pads are marked clearly as in the image above. Use the Navigation Menu to proceed to the Flashing Guides for these Receivers (under the section Flashing Receivers ).","title":"ES915RX (Discontinued)"},{"location":"quick-start/rx-voyager900/","text":"Check your Target \u00b6 Because of the massive shortage of STM32 Chips, there are more ESP8285 based RXes on the market. These support WiFi updating, and can be easily distinguished with a few tricks. The simplest way to tell is if on the rear of the RX (the side without the U.fl/SMD antenna) there is a large white component with the label RainSun (pictured below). If this is not there, you have an STM32 based target, if it is you have an _ESP_ target, and can update using Wifi! Betaflight Passthrough \u00b6 Targets: NamimnoRC_VOYAGER_900_ESP_RX_via_BetaflightPassthrough NamimnoRC_VOYAGER_900_RX_via_BetaflightPassthrough Once wired properly to your FC, connect USB. Did your receiver powered up too (with both LEDs lit)? If so, disconnect USB, hold the bind button on your receiver, and reconnect to USB. The LED should start alternating between the Green and Red LEDs. Once it's alternating, you can then let go of the Bind Button. If your receiver didn't get powered from USB, have a lipo ready and continue with the next steps. On the ExpressLRS Configurator, with your Options set, click on Build & Flash . Like on the TX module, it will take a while on the first time. Watch out for the Passthrough Init stage. This stage will check your FC Configuration for the Serial RX UART (Software Inversion via \"set serialrx_inverted\" and Half Duplex mode via \"set serialrx_halfduplex\" will be checked; both should be off.) Once Retry... lines appear, connect a LiPo if your receiver isn't powered by the USB (i.e. power up your receiver and FC). On subsequent flash, you can have the LiPo plugged in and receiver powered up from the start. Wait for this process to finish. It's done once the \"Success\" prompt is shown. Wifi Updating (ESP Only - Recommended) \u00b6 Target: NamimnoRC_VOYAGER_900_ESP_RX_via_WIFI With the receiver wired properly to your FC, select the right target and set your Firmware Options in the ExpressLRS Configurator. Build the firmware. Once done, it should open a new window where the firmware.bin is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver. Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using AUTO_WIFI_ON_INTERVAL ), it should blink fast indicating it's on Wifi Hotspot Mode. Connect to the Wifi Network the receiver has created. It should be named something like ExpressLRS RX with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1 ). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver firmware.bin is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the Browse or Choose File button). Click on the Update button and the firmware file will be uploaded and the update process should commence. A white page should load momentarily with the message Update Success! Rebooting... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options). UART Updating (ESP Only) \u00b6 Target: NamimnoRC_VOYAGER_900_ESP_RX_via_UART Wire the receiver into the FTDI, with the TX on receiver connected to the Rx on the FTDI, and the RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid. Select the target and set your Firmware Options and once done, click on Build and Flash . STLink Updating (STM32 Only) \u00b6 Target: NamimnoRC_VOYAGER_900_RX_via_STLINK The units provided to the documentation team did not have STM32 chips due to the chip shortage, however, the following should apply. Wire CLK, 3v3, GND and DIO to the recievers STLink pins. Select the target and set your Firmware Options and once done, click on Build and Flash .","title":"Flashing NamimnoRC Voyager"},{"location":"quick-start/rx-voyager900/#check-your-target","text":"Because of the massive shortage of STM32 Chips, there are more ESP8285 based RXes on the market. These support WiFi updating, and can be easily distinguished with a few tricks. The simplest way to tell is if on the rear of the RX (the side without the U.fl/SMD antenna) there is a large white component with the label RainSun (pictured below). If this is not there, you have an STM32 based target, if it is you have an _ESP_ target, and can update using Wifi!","title":"Check your Target"},{"location":"quick-start/rx-voyager900/#betaflight-passthrough","text":"Targets: NamimnoRC_VOYAGER_900_ESP_RX_via_BetaflightPassthrough NamimnoRC_VOYAGER_900_RX_via_BetaflightPassthrough Once wired properly to your FC, connect USB. Did your receiver powered up too (with both LEDs lit)? If so, disconnect USB, hold the bind button on your receiver, and reconnect to USB. The LED should start alternating between the Green and Red LEDs. Once it's alternating, you can then let go of the Bind Button. If your receiver didn't get powered from USB, have a lipo ready and continue with the next steps. On the ExpressLRS Configurator, with your Options set, click on Build & Flash . Like on the TX module, it will take a while on the first time. Watch out for the Passthrough Init stage. This stage will check your FC Configuration for the Serial RX UART (Software Inversion via \"set serialrx_inverted\" and Half Duplex mode via \"set serialrx_halfduplex\" will be checked; both should be off.) Once Retry... lines appear, connect a LiPo if your receiver isn't powered by the USB (i.e. power up your receiver and FC). On subsequent flash, you can have the LiPo plugged in and receiver powered up from the start. Wait for this process to finish. It's done once the \"Success\" prompt is shown.","title":"Betaflight Passthrough"},{"location":"quick-start/rx-voyager900/#wifi-updating-esp-only-recommended","text":"Target: NamimnoRC_VOYAGER_900_ESP_RX_via_WIFI With the receiver wired properly to your FC, select the right target and set your Firmware Options in the ExpressLRS Configurator. Build the firmware. Once done, it should open a new window where the firmware.bin is. Do not close this window so you can easily navigate to it once it's time to upload the firmware into the receiver. Power your Flight Controller by either connecting a LiPo or attaching the USB cable (if the receiver gets powered from USB via a 4v5 pad). The receiver's LED will blink slowly at first, and after 20s or 30s (can be adjusted via ExpressLRS Configurator using AUTO_WIFI_ON_INTERVAL ), it should blink fast indicating it's on Wifi Hotspot Mode. Connect to the Wifi Network the receiver has created. It should be named something like ExpressLRS RX with the same expresslrs password as the TX Module Hotspot. Navigate to the same web address as the TX Module (usually http://10.0.0.1 ). The Firmware upload page should load, and using the File Upload Form, navigate where the correct Receiver firmware.bin is (like with the Tx module, you can also drag-and-drop the firmware file into the form field or use the Browse or Choose File button). Click on the Update button and the firmware file will be uploaded and the update process should commence. A white page should load momentarily with the message Update Success! Rebooting... Wait a little bit (you can wait until the LED on the Receiver starts to blink slowly again) and the receiver should be updated. Power cycle and your module and receiver should now be bound (given you have updated the Tx Module as well, and that they have the same binding phrase and options).","title":"Wifi Updating (ESP Only - Recommended)"},{"location":"quick-start/rx-voyager900/#uart-updating-esp-only","text":"Target: NamimnoRC_VOYAGER_900_ESP_RX_via_UART Wire the receiver into the FTDI, with the TX on receiver connected to the Rx on the FTDI, and the RX on receiver connected to the Tx of the FTDI. Wire 5V and GND of the FTDI to 5V and GND of the Receiver. Press the button while powering the RX on, and release - the LED should now be solid. Select the target and set your Firmware Options and once done, click on Build and Flash .","title":"UART Updating (ESP Only)"},{"location":"quick-start/rx-voyager900/#stlink-updating-stm32-only","text":"Target: NamimnoRC_VOYAGER_900_RX_via_STLINK The units provided to the documentation team did not have STM32 chips due to the chip shortage, however, the following should apply. Wire CLK, 3v3, GND and DIO to the recievers STLink pins. Select the target and set your Firmware Options and once done, click on Build and Flash .","title":"STLink Updating (STM32 Only)"},{"location":"quick-start/troubleshooting/","text":"General Troubleshooting \u00b6 My RX and TX are bound, but Betaflight is not responding to inputs \u00b6 You most likely updated your receiver via WiFi, but you have wired your receiver wrong or that you have an incorrect receiver configuration. You might want to revisit the FC Preparation page for the Flight Controller setup. Also make sure that the UART where you connected the receiver to doesn't have inversion and it's in full duplex mode. You can also try a different UART. Flashing/Updating \u00b6 Invalid serial RX configuration detected \u00b6 This is often caused by incorrect Serial RX protocol (should be CRSF), or serialrx_inverted = on (should be off) or serialrx_halfduplex=on (should be off). The Passthrough Init section of the log will show you which setting should be corrected. See this page for setting up your Flight Controller. RX Serial not found !!!! \u00b6 Make sure your Serial RX on the Ports Tab of your FC Firmware configurator is set to the correct UART. No CLI Available \u00b6 This message can be seen on the ExpressLRS Configurator Log while using the Passthrough method and can be caused by a busy Com Port. Make sure any other Configurator Apps were closed and unplug-replug your FC to USB. You might also want to use a different USB port or cable. This could also mean that the FC cannot be detected by the script. This could also due to the FC being in DFU mode, which for passthrough flashing, is not needed. 10 Retries but no Success \u00b6 This can be due to several things: Incorrect bootloader is flashed or it's not flashed properly. This mainly happen on the R9 receivers. Go checkout Bootloader Flashing Guide . Incorrect wiring. Make sure that Rx in the Receiver is connected to a Tx pad in the FC and the Tx in the Receiver is connected to an Rx pad in the FC. Also make sure receiver is getting enough voltage (min 4v5) from the FC or voltage supply. Wiring guide is here Receiver is OFF. Check whether the LED on the receiver is lit, indicating it's powered and in working state. The UART has hardware inversion. Make sure that the UART you've connected the receiver to is not an SBUS UART that's usually have hardware inversion (most common among F4 Flight Controllers). There are Flight controllers that require you bridge a pair of pads to enable or disable the Hardware inversion of an Rx pad. You can simply try a different UART. The LED on the receiver is SOLID, while radio is off, could only mean that the Rx pad in the FC is being pulled LOW, putting the ESP-based receiver (EPs, ES900Rx, etc.) into Bootloader mode unintentionally, which will hinder normal passthrough operations. Feel free to try a different UART. I updated via WiFi but now receiver won't work and has SOLID LED \u00b6 This is a sign that the Wifi flashing didn't go through properly due to premature power cycle. To fix this, you will have to bridge the boot pads (see here ) and reflash using the Passthrough method or using an FTDI adapter. This video shows the steps albeit using vscode development environment but the ExpressLRS Configurator will work just fine. You might also want to disable Telemetry in Betaflight/emuflight/iNav before attempting recovery. To ensure that the WiFi flashing finished properly, wait until the LED on the receiver blinks slow (indicating it's looking for a TX bind) before pulling off power.","title":"Troubleshooting"},{"location":"quick-start/troubleshooting/#general-troubleshooting","text":"","title":"General Troubleshooting"},{"location":"quick-start/troubleshooting/#my-rx-and-tx-are-bound-but-betaflight-is-not-responding-to-inputs","text":"You most likely updated your receiver via WiFi, but you have wired your receiver wrong or that you have an incorrect receiver configuration. You might want to revisit the FC Preparation page for the Flight Controller setup. Also make sure that the UART where you connected the receiver to doesn't have inversion and it's in full duplex mode. You can also try a different UART.","title":"My RX and TX are bound, but Betaflight is not responding to inputs"},{"location":"quick-start/troubleshooting/#flashingupdating","text":"","title":"Flashing/Updating"},{"location":"quick-start/troubleshooting/#invalid-serial-rx-configuration-detected","text":"This is often caused by incorrect Serial RX protocol (should be CRSF), or serialrx_inverted = on (should be off) or serialrx_halfduplex=on (should be off). The Passthrough Init section of the log will show you which setting should be corrected. See this page for setting up your Flight Controller.","title":"Invalid serial RX configuration detected"},{"location":"quick-start/troubleshooting/#rx-serial-not-found","text":"Make sure your Serial RX on the Ports Tab of your FC Firmware configurator is set to the correct UART.","title":"RX Serial not found !!!!"},{"location":"quick-start/troubleshooting/#no-cli-available","text":"This message can be seen on the ExpressLRS Configurator Log while using the Passthrough method and can be caused by a busy Com Port. Make sure any other Configurator Apps were closed and unplug-replug your FC to USB. You might also want to use a different USB port or cable. This could also mean that the FC cannot be detected by the script. This could also due to the FC being in DFU mode, which for passthrough flashing, is not needed.","title":"No CLI Available"},{"location":"quick-start/troubleshooting/#10-retries-but-no-success","text":"This can be due to several things: Incorrect bootloader is flashed or it's not flashed properly. This mainly happen on the R9 receivers. Go checkout Bootloader Flashing Guide . Incorrect wiring. Make sure that Rx in the Receiver is connected to a Tx pad in the FC and the Tx in the Receiver is connected to an Rx pad in the FC. Also make sure receiver is getting enough voltage (min 4v5) from the FC or voltage supply. Wiring guide is here Receiver is OFF. Check whether the LED on the receiver is lit, indicating it's powered and in working state. The UART has hardware inversion. Make sure that the UART you've connected the receiver to is not an SBUS UART that's usually have hardware inversion (most common among F4 Flight Controllers). There are Flight controllers that require you bridge a pair of pads to enable or disable the Hardware inversion of an Rx pad. You can simply try a different UART. The LED on the receiver is SOLID, while radio is off, could only mean that the Rx pad in the FC is being pulled LOW, putting the ESP-based receiver (EPs, ES900Rx, etc.) into Bootloader mode unintentionally, which will hinder normal passthrough operations. Feel free to try a different UART.","title":"10 Retries but no Success"},{"location":"quick-start/troubleshooting/#i-updated-via-wifi-but-now-receiver-wont-work-and-has-solid-led","text":"This is a sign that the Wifi flashing didn't go through properly due to premature power cycle. To fix this, you will have to bridge the boot pads (see here ) and reflash using the Passthrough method or using an FTDI adapter. This video shows the steps albeit using vscode development environment but the ExpressLRS Configurator will work just fine. You might also want to disable Telemetry in Betaflight/emuflight/iNav before attempting recovery. To ensure that the WiFi flashing finished properly, wait until the LED on the receiver blinks slow (indicating it's looking for a TX bind) before pulling off power.","title":"I updated via WiFi but now receiver won't work and has SOLID LED"},{"location":"quick-start/tx-betafpv2400/","text":"Flashing via Wifi \u00b6 Target: BETAFPV_2400_TX_via_WIFI With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the firmware.bin file is. Do not close this window so you can easily locate the correct file to upload to the module. The next steps will require the ELRS Lua Script (right-click, save as). Download the ELRS.lua script and save it to your Radio's /Scripts/Tools folder. Insert/attach your module into your module bay and make sure it's not loose and there's proper connection with the radio. Execute the ELRS.lua script by pressing \"System Menu\" in your radio and then under Tools, select ELRS.lua. At first, it will show \"Mismatch\"; it's normal. Tap Enter once on your radio to \"Force Use\" the script. If it's showing a \"Connecting\" message, then recheck the connection of the module to your radio. Select Wifi Update from the lua script. The Lua script will instruct you to go to a specific Ip Address, but you have to first connect to the Wifi Hotspot it created. It will show up in your network as ExpressLRS TX Module , and the password is simply expresslrs . Using your browser, navigate to the correct page (typically http://10.0.0.1/ ) and it should show an upload form (you will have to scroll down a bit). You can drag-and-drop the firmware.bin file from the folder that ExpressLRS Configurator opened for you, or you can manually navigate to it via the Browse or Choose File button on the Upload form. Click on Update once and the update process should commence. Take note that you should be taking a TX firmware.bin file. The folder name where you can get this file is the same as the Target you have selected in the ExpressLRS Configurator. Once the file is uploaded, the webserver should load a White page, with the message Update Success! Rebooting... As it rebooted, the connection to the Webserver got terminated. Check via the Lua Script whether you have successfully updated the TX module. The first line of the lua script should show a 6-character hash that corresponds to the Git commit hash for the firmware version you have on the module. There should be no more \"Mismatch\" messages as well. Flashing via USB/UART \u00b6 Target: BETAFPV_2400_TX_via_UART Attach a USB Data Cable to your module and Computer. Windows users might have to install CP210x Drivers to ensure the device is properly detected and initialized. Using the ExpressLRS Configurator with the correct Target selected and options set, hit Build & Flash . Wait for the process to finish, and you should be greeted with the \"Success\" message. Verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module. Can't flash? \u00b6 If you've followed any of the steps above and still can't get your devices flashed and updated, see this video for the explanation why and the fix to get your devices flashed and updated.","title":"Flashing BetaFPV Nano 2.4Ghz"},{"location":"quick-start/tx-betafpv2400/#flashing-via-wifi","text":"Target: BETAFPV_2400_TX_via_WIFI With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the firmware.bin file is. Do not close this window so you can easily locate the correct file to upload to the module. The next steps will require the ELRS Lua Script (right-click, save as). Download the ELRS.lua script and save it to your Radio's /Scripts/Tools folder. Insert/attach your module into your module bay and make sure it's not loose and there's proper connection with the radio. Execute the ELRS.lua script by pressing \"System Menu\" in your radio and then under Tools, select ELRS.lua. At first, it will show \"Mismatch\"; it's normal. Tap Enter once on your radio to \"Force Use\" the script. If it's showing a \"Connecting\" message, then recheck the connection of the module to your radio. Select Wifi Update from the lua script. The Lua script will instruct you to go to a specific Ip Address, but you have to first connect to the Wifi Hotspot it created. It will show up in your network as ExpressLRS TX Module , and the password is simply expresslrs . Using your browser, navigate to the correct page (typically http://10.0.0.1/ ) and it should show an upload form (you will have to scroll down a bit). You can drag-and-drop the firmware.bin file from the folder that ExpressLRS Configurator opened for you, or you can manually navigate to it via the Browse or Choose File button on the Upload form. Click on Update once and the update process should commence. Take note that you should be taking a TX firmware.bin file. The folder name where you can get this file is the same as the Target you have selected in the ExpressLRS Configurator. Once the file is uploaded, the webserver should load a White page, with the message Update Success! Rebooting... As it rebooted, the connection to the Webserver got terminated. Check via the Lua Script whether you have successfully updated the TX module. The first line of the lua script should show a 6-character hash that corresponds to the Git commit hash for the firmware version you have on the module. There should be no more \"Mismatch\" messages as well.","title":"Flashing via Wifi"},{"location":"quick-start/tx-betafpv2400/#flashing-via-usbuart","text":"Target: BETAFPV_2400_TX_via_UART Attach a USB Data Cable to your module and Computer. Windows users might have to install CP210x Drivers to ensure the device is properly detected and initialized. Using the ExpressLRS Configurator with the correct Target selected and options set, hit Build & Flash . Wait for the process to finish, and you should be greeted with the \"Success\" message. Verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.","title":"Flashing via USB/UART"},{"location":"quick-start/tx-betafpv2400/#cant-flash","text":"If you've followed any of the steps above and still can't get your devices flashed and updated, see this video for the explanation why and the fix to get your devices flashed and updated.","title":"Can't flash?"},{"location":"quick-start/tx-betafpv900/","text":"Flashing via Wifi \u00b6 Target: BETAFPV_900_TX_via_WIFI With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the firmware.bin file is. Do not close this window so you can easily locate the correct file to upload to the module. The next steps will require the ELRS Lua Script (right-click, save as). Download the ELRS.lua script and save it to your Radio's /Scripts/Tools folder. Insert/attach your module into your module bay and make sure it's not loose and there's proper connection with the radio. Execute the ELRS.lua script by pressing \"System Menu\" in your radio and then under Tools, select ELRS.lua. At first, it will show \"Mismatch\"; it's normal. Tap Enter once on your radio to \"Force Use\" the script. If it's showing a \"Connecting\" message, then recheck the connection of the module to your radio. Select Wifi Update from the lua script. The Lua script will instruct you to go to a specific Ip Address, but you have to first connect to the Wifi Hotspot it created. It will show up in your network as ExpressLRS TX Module , and the password is simply expresslrs . Using your browser, navigate to the correct page (typically http://10.0.0.1/ ) and it should show an upload form (you will have to scroll down a bit). You can drag-and-drop the firmware.bin file from the folder that ExpressLRS Configurator opened for you, or you can manually navigate to it via the Browse or Choose File button on the Upload form. Click on Update once and the update process should commence. Take note that you should be taking a TX firmware.bin file. The folder name where you can get this file is the same as the Target you have selected in the ExpressLRS Configurator. Once the file is uploaded, the webserver should load a White page, with the message Update Success! Rebooting... As it rebooted, the connection to the Webserver got terminated. Check via the Lua Script whether you have successfully updated the TX module. The first line of the lua script should show a 6-character hash that corresponds to the Git commit hash for the firmware version you have on the module. There should be no more \"Mismatch\" messages as well. Flashing via USB/UART \u00b6 Target: BETAFPV_900_TX_via_UART Attach a USB Data Cable to your module and Computer. Windows users might have to install CP210x Drivers to ensure the device is properly detected and initialized. Using the ExpressLRS Configurator with the correct Target selected and options set, hit Build & Flash . Wait for the process to finish, and you should be greeted with the \"Success\" message. Verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module. Can't flash? \u00b6 If you've followed any of the steps above and still can't get your devices flashed and updated, see this video for the explanation why and the fix to get your devices flashed and updated.","title":"Flashing BetaFPV Nano 900Mhz"},{"location":"quick-start/tx-betafpv900/#flashing-via-wifi","text":"Target: BETAFPV_900_TX_via_WIFI With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the firmware.bin file is. Do not close this window so you can easily locate the correct file to upload to the module. The next steps will require the ELRS Lua Script (right-click, save as). Download the ELRS.lua script and save it to your Radio's /Scripts/Tools folder. Insert/attach your module into your module bay and make sure it's not loose and there's proper connection with the radio. Execute the ELRS.lua script by pressing \"System Menu\" in your radio and then under Tools, select ELRS.lua. At first, it will show \"Mismatch\"; it's normal. Tap Enter once on your radio to \"Force Use\" the script. If it's showing a \"Connecting\" message, then recheck the connection of the module to your radio. Select Wifi Update from the lua script. The Lua script will instruct you to go to a specific Ip Address, but you have to first connect to the Wifi Hotspot it created. It will show up in your network as ExpressLRS TX Module , and the password is simply expresslrs . Using your browser, navigate to the correct page (typically http://10.0.0.1/ ) and it should show an upload form (you will have to scroll down a bit). You can drag-and-drop the firmware.bin file from the folder that ExpressLRS Configurator opened for you, or you can manually navigate to it via the Browse or Choose File button on the Upload form. Click on Update once and the update process should commence. Take note that you should be taking a TX firmware.bin file. The folder name where you can get this file is the same as the Target you have selected in the ExpressLRS Configurator. Once the file is uploaded, the webserver should load a White page, with the message Update Success! Rebooting... As it rebooted, the connection to the Webserver got terminated. Check via the Lua Script whether you have successfully updated the TX module. The first line of the lua script should show a 6-character hash that corresponds to the Git commit hash for the firmware version you have on the module. There should be no more \"Mismatch\" messages as well.","title":"Flashing via Wifi"},{"location":"quick-start/tx-betafpv900/#flashing-via-usbuart","text":"Target: BETAFPV_900_TX_via_UART Attach a USB Data Cable to your module and Computer. Windows users might have to install CP210x Drivers to ensure the device is properly detected and initialized. Using the ExpressLRS Configurator with the correct Target selected and options set, hit Build & Flash . Wait for the process to finish, and you should be greeted with the \"Success\" message. Verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.","title":"Flashing via USB/UART"},{"location":"quick-start/tx-betafpv900/#cant-flash","text":"If you've followed any of the steps above and still can't get your devices flashed and updated, see this video for the explanation why and the fix to get your devices flashed and updated.","title":"Can't flash?"},{"location":"quick-start/tx-diy/","text":"Valid Targets: DIY_2400_TX_ESP32_SX1280_E28_via_UART DIY_2400_TX_ESP32_SX1280_LORA1280F27_via_UART DIY_2400_TX_ESP32_SX1280_Mini_via_UART Plug the ESP32 of the DIY TX into the USB of your computer. Then select the correct target given the RF chip you chose and press Build & Flash . Further updates can be performed by building and flashing the .bin file to the external module using OpenTX.","title":"Flashing DIY 2400TX"},{"location":"quick-start/tx-diy900/","text":"ESP32 Targets \u00b6 Valid Targets: - DIY_900_TX_ESP32_SX127x_E19_via_UART - DIY_900_TX_ESP32_SX127x_RFM95_via_UART Plug the ESP32 of the DIY TX into the USB of your computer. Then select the correct target given the RF chip you chose and press Build & Flash . Further updates can be performed by building and flashing the .bin file to the external module using OpenTX. TTGo Targets \u00b6 Valid Targets: - DIY_900_TX_TTGO_V1_SX127x_via_UART - DIY_900_TX_TTGO_V2_SX127x_via_UART Plug the TTGo into the USB of your computer. Then select the correct target given the version you have and press Build & Flash . Further updates can be performed by building and flashing the .bin file to the external module using OpenTX.","title":"Flashing DIY 900TX"},{"location":"quick-start/tx-diy900/#esp32-targets","text":"Valid Targets: - DIY_900_TX_ESP32_SX127x_E19_via_UART - DIY_900_TX_ESP32_SX127x_RFM95_via_UART Plug the ESP32 of the DIY TX into the USB of your computer. Then select the correct target given the RF chip you chose and press Build & Flash . Further updates can be performed by building and flashing the .bin file to the external module using OpenTX.","title":"ESP32 Targets"},{"location":"quick-start/tx-diy900/#ttgo-targets","text":"Valid Targets: - DIY_900_TX_TTGO_V1_SX127x_via_UART - DIY_900_TX_TTGO_V2_SX127x_via_UART Plug the TTGo into the USB of your computer. Then select the correct target given the version you have and press Build & Flash . Further updates can be performed by building and flashing the .bin file to the external module using OpenTX.","title":"TTGo Targets"},{"location":"quick-start/tx-es24tx/","text":"Flashing via WiFi \u00b6 Target: HappyModel_ES24TX_2400_TX_via_WIFI With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the firmware.bin file is. Do not close this window so you can easily locate the correct file to upload to the module. The next steps will require the ELRS Lua Script (right-click, save as). Download the ELRS.lua script and save it to your Radio's /Scripts/Tools folder. Insert/attach your module into your module bay and make sure it's not loose and there's proper connection with the radio. Execute the ELRS.lua script by pressing \"System Menu\" in your radio and then under Tools, select ELRS.lua. At first, it will show \"Mismatch\"; it's normal. Tap Enter once on your radio to \"Force Use\" the script. If it's showing a \"Connecting\" message, then recheck the connection of the module to your radio. Select \"Wifi Update\" from the lua script. The Lua script will instruct you to go to a specific Ip Address, but you have to first connect to the Wifi Hotspot it created. It will show up in your network as ExpressLRS TX Module , and the password is simply expresslrs . Using your browser, navigate to the correct page (typically http://10.0.0.1/ ) and it should show an upload form (you will have to scroll down a bit). You can drag-and-drop the firmware.bin file from the folder that ExpressLRS Configurator opened for you, or you can manually navigate to it via the Browse or Choose File button on the Upload form. Click on Update once and the update process should commence. Take note that you should be taking a TX firmware.bin file. The folder name where you can get this file is the same as the Target you have selected in the ExpressLRS Configurator. Once the file is uploaded, the webserver should load a White page, with the message Update Success! Rebooting... As it rebooted, the connection to the Webserver got terminated. Check via the Lua Script whether you have successfully updated the TX module. The first line of the lua script should show a 6-character hash that corresponds to the Git commit hash for the firmware version you have on the module. There should be no more \"Mismatch\" messages as well. Flashing via USB/UART \u00b6 Target: HappyModel_ES24TX_2400_TX_via_UART This method requires you move two jumpers into specific pins in the module board. See the following image for the jumper location and which pin should be bridged for this method to work. The jumpers should be moved into the USB/UART (Green) position from the images above. Attach your USB cable into the module and your computer. CP210x Drivers will have to be installed for this to work properly (Windows). Make sure your computer recognizes the module as a USB-to-UART Bridge device, otherwise, this method will not work. Using the ExpressLRS Configurator with the correct Target selected and options set, hit Build & Flash . Wait for the process to finish, and you should be greeted with the \"Success\" message. Assemble the module back together and attach it to your radio module bay and verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.","title":"Flashing Happymodel ES24TX"},{"location":"quick-start/tx-es24tx/#flashing-via-wifi","text":"Target: HappyModel_ES24TX_2400_TX_via_WIFI With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the firmware.bin file is. Do not close this window so you can easily locate the correct file to upload to the module. The next steps will require the ELRS Lua Script (right-click, save as). Download the ELRS.lua script and save it to your Radio's /Scripts/Tools folder. Insert/attach your module into your module bay and make sure it's not loose and there's proper connection with the radio. Execute the ELRS.lua script by pressing \"System Menu\" in your radio and then under Tools, select ELRS.lua. At first, it will show \"Mismatch\"; it's normal. Tap Enter once on your radio to \"Force Use\" the script. If it's showing a \"Connecting\" message, then recheck the connection of the module to your radio. Select \"Wifi Update\" from the lua script. The Lua script will instruct you to go to a specific Ip Address, but you have to first connect to the Wifi Hotspot it created. It will show up in your network as ExpressLRS TX Module , and the password is simply expresslrs . Using your browser, navigate to the correct page (typically http://10.0.0.1/ ) and it should show an upload form (you will have to scroll down a bit). You can drag-and-drop the firmware.bin file from the folder that ExpressLRS Configurator opened for you, or you can manually navigate to it via the Browse or Choose File button on the Upload form. Click on Update once and the update process should commence. Take note that you should be taking a TX firmware.bin file. The folder name where you can get this file is the same as the Target you have selected in the ExpressLRS Configurator. Once the file is uploaded, the webserver should load a White page, with the message Update Success! Rebooting... As it rebooted, the connection to the Webserver got terminated. Check via the Lua Script whether you have successfully updated the TX module. The first line of the lua script should show a 6-character hash that corresponds to the Git commit hash for the firmware version you have on the module. There should be no more \"Mismatch\" messages as well.","title":"Flashing via WiFi"},{"location":"quick-start/tx-es24tx/#flashing-via-usbuart","text":"Target: HappyModel_ES24TX_2400_TX_via_UART This method requires you move two jumpers into specific pins in the module board. See the following image for the jumper location and which pin should be bridged for this method to work. The jumpers should be moved into the USB/UART (Green) position from the images above. Attach your USB cable into the module and your computer. CP210x Drivers will have to be installed for this to work properly (Windows). Make sure your computer recognizes the module as a USB-to-UART Bridge device, otherwise, this method will not work. Using the ExpressLRS Configurator with the correct Target selected and options set, hit Build & Flash . Wait for the process to finish, and you should be greeted with the \"Success\" message. Assemble the module back together and attach it to your radio module bay and verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.","title":"Flashing via USB/UART"},{"location":"quick-start/tx-es900tx/","text":"ES900TX \u00b6 Flashing via Wifi \u00b6 Target: HappyModel_TX_ES900TX_via_WIFI With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the firmware.bin file is. Do not close this window so you can easily locate the correct file to upload to the module. The next steps will require the ELRS Lua Script (right-click, save as). Download the ELRS.lua script and save it to your Radio's /Scripts/Tools folder. Insert/attach your module into your module bay and make sure it's not loose and there's proper connection with the radio. Execute the ELRS.lua script by pressing \"System Menu\" in your radio and then under Tools, select ELRS.lua. At first, it will show \"Mismatch\"; it's normal. Tap Enter once on your radio to \"Force Use\" the script. If it's showing a \"Connecting\" message, then recheck the connection of the module to your radio. Select \"Wifi Update\" from the lua script. The Lua script will instruct you to go to a specific Ip Address, but you have to first connect to the Wifi Hotspot it created. It will show up in your network as ExpressLRS TX Module , and the password is simply expresslrs . Using your browser, navigate to the correct page (typically http://10.0.0.1/ ) and it should show an upload form (you will have to scroll down a bit). You can drag-and-drop the firmware.bin file from the folder that ExpressLRS Configurator opened for you, or you can manually navigate to it via the Browse or Choose File button on the Upload form. Click on Update once and the update process should commence. Take note that you should be taking a TX firmware.bin file. The folder name where you can get this file is the same as the Target you have selected in the ExpressLRS Configurator. Once the file is uploaded, the webserver should load a White page, with the message Update Success! Rebooting... As it rebooted, the connection to the Webserver got terminated. Check via the Lua Script whether you have successfully updated the TX module. The first line of the lua script should show a 6-character hash that corresponds to the Git commit hash for the firmware version you have on the module. There should be no more \"Mismatch\" messages as well. Flashing via USB \u00b6 Target: HappyModel_TX_ES900TX_via_UART This method requires you move two jumpers into specific pins in the module board. See the following image for the jumper location and which pin should be bridged for this method to work. The 2 bottom-most dipswitch should be moved into the position as shown in the image above. Attach your USB cable into the module and your computer. CP210x Drivers will have to be installed for this to work properly (Windows). Make sure your computer recognizes the module as a USB-to-UART Bridge device, otherwise, this method will not work. Using the ExpressLRS Configurator with the correct Target selected and options set, hit Build & Flash . Wait for the process to finish, and you should be greeted with the \"Success\" message. Assemble the module back together and attach it to your radio module bay and verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module. ES915/868TX (Discontinued) \u00b6 Flashing via OpenTX \u00b6 Target: HappyModel_TX_ES915TX_via_stock_BL Using Build in the ExpressLRS Configurator, wait for the firmware to be compiled. After that's done, ExpressLRS Configurator Log should show the Success Message, and it will automatically open the folder where the firmware.elrs can be found. Put (copy-paste) the firmware.elrs to your Radio's SD Card (preferably to the /FIRMWARE folder for easy access). Once on your radio, navigate to the /FIRMWARE folder, select the firmware.elrs and click-hold the Enter button and select \"Flash External ELRS\". Wait for the flashing to finish, module will reboot and you should hear the tune and two beeps (if external module is now set to CRSF protocol). Flashing via STLink \u00b6 Target: HappyModel_TX_ES915TX_via_STLINK Connect your STLink v2 to the pads shown on the image below. With the module connected shown above, and your configuration set, hit Build & Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. The ExpressLRS tune should play and then two beeps after that can be heard. Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.","title":"Flashing Happymodel ES900TX"},{"location":"quick-start/tx-es900tx/#es900tx","text":"","title":"ES900TX"},{"location":"quick-start/tx-es900tx/#flashing-via-wifi","text":"Target: HappyModel_TX_ES900TX_via_WIFI With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the firmware.bin file is. Do not close this window so you can easily locate the correct file to upload to the module. The next steps will require the ELRS Lua Script (right-click, save as). Download the ELRS.lua script and save it to your Radio's /Scripts/Tools folder. Insert/attach your module into your module bay and make sure it's not loose and there's proper connection with the radio. Execute the ELRS.lua script by pressing \"System Menu\" in your radio and then under Tools, select ELRS.lua. At first, it will show \"Mismatch\"; it's normal. Tap Enter once on your radio to \"Force Use\" the script. If it's showing a \"Connecting\" message, then recheck the connection of the module to your radio. Select \"Wifi Update\" from the lua script. The Lua script will instruct you to go to a specific Ip Address, but you have to first connect to the Wifi Hotspot it created. It will show up in your network as ExpressLRS TX Module , and the password is simply expresslrs . Using your browser, navigate to the correct page (typically http://10.0.0.1/ ) and it should show an upload form (you will have to scroll down a bit). You can drag-and-drop the firmware.bin file from the folder that ExpressLRS Configurator opened for you, or you can manually navigate to it via the Browse or Choose File button on the Upload form. Click on Update once and the update process should commence. Take note that you should be taking a TX firmware.bin file. The folder name where you can get this file is the same as the Target you have selected in the ExpressLRS Configurator. Once the file is uploaded, the webserver should load a White page, with the message Update Success! Rebooting... As it rebooted, the connection to the Webserver got terminated. Check via the Lua Script whether you have successfully updated the TX module. The first line of the lua script should show a 6-character hash that corresponds to the Git commit hash for the firmware version you have on the module. There should be no more \"Mismatch\" messages as well.","title":"Flashing via Wifi"},{"location":"quick-start/tx-es900tx/#flashing-via-usb","text":"Target: HappyModel_TX_ES900TX_via_UART This method requires you move two jumpers into specific pins in the module board. See the following image for the jumper location and which pin should be bridged for this method to work. The 2 bottom-most dipswitch should be moved into the position as shown in the image above. Attach your USB cable into the module and your computer. CP210x Drivers will have to be installed for this to work properly (Windows). Make sure your computer recognizes the module as a USB-to-UART Bridge device, otherwise, this method will not work. Using the ExpressLRS Configurator with the correct Target selected and options set, hit Build & Flash . Wait for the process to finish, and you should be greeted with the \"Success\" message. Assemble the module back together and attach it to your radio module bay and verify with the ELRS.lua script if you have successfully updated your module using the Git commit hash for the firmware version you have on the module.","title":"Flashing via USB"},{"location":"quick-start/tx-es900tx/#es915868tx-discontinued","text":"","title":"ES915/868TX (Discontinued)"},{"location":"quick-start/tx-es900tx/#flashing-via-opentx","text":"Target: HappyModel_TX_ES915TX_via_stock_BL Using Build in the ExpressLRS Configurator, wait for the firmware to be compiled. After that's done, ExpressLRS Configurator Log should show the Success Message, and it will automatically open the folder where the firmware.elrs can be found. Put (copy-paste) the firmware.elrs to your Radio's SD Card (preferably to the /FIRMWARE folder for easy access). Once on your radio, navigate to the /FIRMWARE folder, select the firmware.elrs and click-hold the Enter button and select \"Flash External ELRS\". Wait for the flashing to finish, module will reboot and you should hear the tune and two beeps (if external module is now set to CRSF protocol).","title":"Flashing via OpenTX"},{"location":"quick-start/tx-es900tx/#flashing-via-stlink","text":"Target: HappyModel_TX_ES915TX_via_STLINK Connect your STLink v2 to the pads shown on the image below. With the module connected shown above, and your configuration set, hit Build & Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. The ExpressLRS tune should play and then two beeps after that can be heard. Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.","title":"Flashing via STLink"},{"location":"quick-start/tx-flash2400/","text":"Flashing via Wifi \u00b6 Target: NamimnoRC_Flash_2400_TX_via_WiFi Method 1 \u00b6 With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the firmware.bin file is. Do not close this window so you can easily locate the correct file to upload to the module. These Tx Modules are STM32-based so they require a separate ESP \"backpack\" device for Wifi Flashing/Updating. The Wifi Update option in the ExpressLRS Lua script will not work with these devices. The steps that follow will be used instead. Attach the module to your JR Bays and power it up. Connect to the ESP Wifi Manager Hotspot that the device will activate. Once connected, navigate to http://elrs_tx.local/ (IP: 192.168.4.1). Press Configure WiFi and set your home network SSID and password. This will enable your Tx Module to connect to your local home network. On your browser, refresh the http://elrs_tx.local/ and scroll towards the STM32 Firmware Update section, as shown below: Drag-and-drop the firmware.bin file created by the ExpressLRS Configurator into the Choose File field, or manually navigate to the Folder by clicking the Choose File button. Once the correct file is selected, click the Upload and Flash STM32 . Wait for the process to complete, and the module will reboot (~2-3min). Using the ELRS.lua script, verify that you have the latest version. Method 2 \u00b6 These Tx Modules are STM32-based so they require a separate ESP \"backpack\" device for Wifi Flashing/Updating. The Wifi Update option in the ExpressLRS Lua script will not work with these devices. The steps that follow will be used instead. Attach the module to your JR Bays and power it up. Connect to the ESP Wifi Manager Hotspot that the device will activate. Once connected, navigate to http://elrs_tx.local/ (IP: 192.168.4.1). Press Configure WiFi and set your home network SSID and password. This will enable your Tx Module to connect to your local home network. Using the ExpressLRS Configurator, select the correct Target and set your Firmware Options . Click Build and Flash and wait for the compile process to complete. You should see a section as pictured below and the Success message marking the update process complete. Using the ELRS.lua script, verify that you have the latest version. Flashing via STLink \u00b6 Target: NamimnoRC_Flash_2400_TX_via_STLINK ONLY USE THIS METHOD IF THE FIRMWARE HAS BEEN CORRUPTED Begin by disassembling the module by unscrewing the 4 screws at the rear of the module with a 1.5mm hex wrench. Carefully seperate the parts of the module and detach the cable from the main PCB. Wire your STLink v2 to the module's pins as show below: With the module connected shown above, and your configuration set, hit Build & Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. If the Radio has CRSF selected, the light should turn green meaning the module has communication with your radio. Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.","title":"Flashing NamimnoRC Flash"},{"location":"quick-start/tx-flash2400/#flashing-via-wifi","text":"Target: NamimnoRC_Flash_2400_TX_via_WiFi","title":"Flashing via Wifi"},{"location":"quick-start/tx-flash2400/#method-1","text":"With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the firmware.bin file is. Do not close this window so you can easily locate the correct file to upload to the module. These Tx Modules are STM32-based so they require a separate ESP \"backpack\" device for Wifi Flashing/Updating. The Wifi Update option in the ExpressLRS Lua script will not work with these devices. The steps that follow will be used instead. Attach the module to your JR Bays and power it up. Connect to the ESP Wifi Manager Hotspot that the device will activate. Once connected, navigate to http://elrs_tx.local/ (IP: 192.168.4.1). Press Configure WiFi and set your home network SSID and password. This will enable your Tx Module to connect to your local home network. On your browser, refresh the http://elrs_tx.local/ and scroll towards the STM32 Firmware Update section, as shown below: Drag-and-drop the firmware.bin file created by the ExpressLRS Configurator into the Choose File field, or manually navigate to the Folder by clicking the Choose File button. Once the correct file is selected, click the Upload and Flash STM32 . Wait for the process to complete, and the module will reboot (~2-3min). Using the ELRS.lua script, verify that you have the latest version.","title":"Method 1"},{"location":"quick-start/tx-flash2400/#method-2","text":"These Tx Modules are STM32-based so they require a separate ESP \"backpack\" device for Wifi Flashing/Updating. The Wifi Update option in the ExpressLRS Lua script will not work with these devices. The steps that follow will be used instead. Attach the module to your JR Bays and power it up. Connect to the ESP Wifi Manager Hotspot that the device will activate. Once connected, navigate to http://elrs_tx.local/ (IP: 192.168.4.1). Press Configure WiFi and set your home network SSID and password. This will enable your Tx Module to connect to your local home network. Using the ExpressLRS Configurator, select the correct Target and set your Firmware Options . Click Build and Flash and wait for the compile process to complete. You should see a section as pictured below and the Success message marking the update process complete. Using the ELRS.lua script, verify that you have the latest version.","title":"Method 2"},{"location":"quick-start/tx-flash2400/#flashing-via-stlink","text":"Target: NamimnoRC_Flash_2400_TX_via_STLINK ONLY USE THIS METHOD IF THE FIRMWARE HAS BEEN CORRUPTED Begin by disassembling the module by unscrewing the 4 screws at the rear of the module with a 1.5mm hex wrench. Carefully seperate the parts of the module and detach the cable from the main PCB. Wire your STLink v2 to the module's pins as show below: With the module connected shown above, and your configuration set, hit Build & Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. If the Radio has CRSF selected, the light should turn green meaning the module has communication with your radio. Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.","title":"Flashing via STLink"},{"location":"quick-start/tx-ghost2400/","text":"Flashing Ghost Modules via STLink \u00b6 Targets: GHOST_2400_TX_via_STLINK GHOST_2400_TX_LITE_via_STLINK Initial Flash \u00b6 Here is a 10 minute video, showing the steps required to both flash the TX if you would rather watch than read: Flashing the Ghost TX's is currently a 1 WAY flash once you flash ExpressLRS to the TX you will not be able to use it with stock Ghost RX's (running stock firmware, they will work while running ELRS). You will need a StLink V2 to flash the TX Wire 3.3v , GND , CLK , and DIO to their respective pins on your part from the StLink. (You can power with the StLink but in the first two image the radio is used to power the module). Here is the output/input antennas of the TX: Updating \u00b6 Updating can be done by building an updated version on the configurator and then flashing the firmware.bin file using OpenTX.","title":"Flashing Ghost TX"},{"location":"quick-start/tx-ghost2400/#flashing-ghost-modules-via-stlink","text":"Targets: GHOST_2400_TX_via_STLINK GHOST_2400_TX_LITE_via_STLINK","title":"Flashing Ghost Modules via STLink"},{"location":"quick-start/tx-ghost2400/#initial-flash","text":"Here is a 10 minute video, showing the steps required to both flash the TX if you would rather watch than read: Flashing the Ghost TX's is currently a 1 WAY flash once you flash ExpressLRS to the TX you will not be able to use it with stock Ghost RX's (running stock firmware, they will work while running ELRS). You will need a StLink V2 to flash the TX Wire 3.3v , GND , CLK , and DIO to their respective pins on your part from the StLink. (You can power with the StLink but in the first two image the radio is used to power the module). Here is the output/input antennas of the TX:","title":"Initial Flash"},{"location":"quick-start/tx-ghost2400/#updating","text":"Updating can be done by building an updated version on the configurator and then flashing the firmware.bin file using OpenTX.","title":"Updating"},{"location":"quick-start/tx-prep/","text":"Flashing the Latest OpenTX or EdgeTX for CRSFShot/Mixer Sync \u00b6 ExpressLRS requires CRSFShot or Mixer Sync to ensure full support for high packet rates. Starting with OpenTX-2.3.12 , CRSFshot has been fully implemented, and thus you will have to update your OpenTX radio to these newer versions. Another alternative is EdgeTX , the bleeding edge fork of OpenTX. These firmwares allow flashing of .elrs files too. CRSF Protocol \u00b6 ExpressLRS uses the CRSF serial protocol to communicate between the transmitter and the TX module. To set this up, enter into your model settings, and on the \"Model Setup\" tab, enable your \"External RF\" and select \"CRSF\" as the protocol: NOTE: Make sure the internal module is turned off. NOTE: Make sure the internal module is turned off. Serial Baud Rate \u00b6 On some transmitters, the baud rate for comms between the opentx and the ExpressLRS module can be changed. The two rates available are 115200 and 400000. ExpressLRS supports both rates (auto switches to the correct rate on power-up), however, we have found that on the R9M 2018 modules, the inverter IC's that are used are not capable of reliably handling 400k baud. If you're using an R9M 2018 module, select 115200 baud in OpenTX, or do the resistor mod described on the R9M 2018 Resistor Mod page. The QX7, X10/S, X12 will also going to require the Crossfire Mod if you're going to use 400k baud rates for use with higher packet rates, particularly with the 2.4G ExpressLRS Modules. Alternatively, EdgeTX can be flashed into these Radios and have OneBit enabled. The X9D(plus) can't change its Max Bauds settings, but it has been found to be finicky, causing unstable packet transfers, and constant Telemetry Lost/Recovered messages from OpenTX. One fix for this is the use of the OneBit firmware or EdgeTX. Click here for more info. ADC Filter \u00b6 The ADC filter is enabled by default in OpenTX and is known to cause issues with RC Command data. This can result in \"jagged\" RC command responses in black box logs, caused by sequential RC packets that have the same command value (which were \"smoothed\" by the ADC filter). We recommend turning the ADC filter OFF in OpenTX . Lua Script \u00b6 For faster access to the Lua script, save the ELRS.lua File from this link: ExLRS Lua Script onto the radio's SD Card in the Scripts/Tools folder and Long Press the \"SYS\" button (for T16 or similar Radios) or the \"Menu\" button (for Taranis X9D or similar Radios) to access the Tools Menu where you can find ELRS script ready to run with only one click. Another way to get the ELRS Lua Script is via the ExpressLRS Configurator. Here's how it looks in the Tools Menu: Note: For devices not yet flashed with ExpressLRS, the section below will not work. The Lua script has an important feature that's highly valuable with troubleshooting. On the first line, after the 6-character version hash, it shows an indicator 0:nnn which tells you how many bad UART packets and how many good UART packets per second it's getting from the radio. It can be used to confirm the communication between the Radio and the TX module is working properly. e.g. if you have set the Packet Rate to 200Hz, 0:200 means 0 bad packets and 200 good packets. The second number should match the selected packet rate (200 for 200Hz, 500 for 500Hz, etc..) If it doesn't and is stuck at 250 that means CRSFshot isn't working. Go back to the top of this page and verify you've done all the steps above correctly. Troubleshooting Lua Script \u00b6 \"Connecting\" showing on the Lua Script would mean the Protocol set for the External Module is incorrect or that the module is not properly connected to the pins of the jr bay of the radio. The latter could mean that the module's PCB has gotten loose, common with the first batches of the ES24TX modules from Happymodel. If the number up top the lua script is showing 0:142, etc., have a look at your model settings and make sure the internal RF module is set to off. The \"33e2a6\" from the photo above is the Commit Hash of the firmware version that the module has. You can reference this hash from Releases . If you can't find the commit hash from the Releases page, this could mean you are using firmware from the manufacturer's own fork of the ExpressLRS code. Now that your radio is set, you can now proceed with flashing ExpressLRS!","title":"Preparing your Radio"},{"location":"quick-start/tx-prep/#flashing-the-latest-opentx-or-edgetx-for-crsfshotmixer-sync","text":"ExpressLRS requires CRSFShot or Mixer Sync to ensure full support for high packet rates. Starting with OpenTX-2.3.12 , CRSFshot has been fully implemented, and thus you will have to update your OpenTX radio to these newer versions. Another alternative is EdgeTX , the bleeding edge fork of OpenTX. These firmwares allow flashing of .elrs files too.","title":"Flashing the Latest OpenTX or EdgeTX for CRSFShot/Mixer Sync"},{"location":"quick-start/tx-prep/#crsf-protocol","text":"ExpressLRS uses the CRSF serial protocol to communicate between the transmitter and the TX module. To set this up, enter into your model settings, and on the \"Model Setup\" tab, enable your \"External RF\" and select \"CRSF\" as the protocol: NOTE: Make sure the internal module is turned off. NOTE: Make sure the internal module is turned off.","title":"CRSF Protocol"},{"location":"quick-start/tx-prep/#serial-baud-rate","text":"On some transmitters, the baud rate for comms between the opentx and the ExpressLRS module can be changed. The two rates available are 115200 and 400000. ExpressLRS supports both rates (auto switches to the correct rate on power-up), however, we have found that on the R9M 2018 modules, the inverter IC's that are used are not capable of reliably handling 400k baud. If you're using an R9M 2018 module, select 115200 baud in OpenTX, or do the resistor mod described on the R9M 2018 Resistor Mod page. The QX7, X10/S, X12 will also going to require the Crossfire Mod if you're going to use 400k baud rates for use with higher packet rates, particularly with the 2.4G ExpressLRS Modules. Alternatively, EdgeTX can be flashed into these Radios and have OneBit enabled. The X9D(plus) can't change its Max Bauds settings, but it has been found to be finicky, causing unstable packet transfers, and constant Telemetry Lost/Recovered messages from OpenTX. One fix for this is the use of the OneBit firmware or EdgeTX. Click here for more info.","title":"Serial Baud Rate"},{"location":"quick-start/tx-prep/#adc-filter","text":"The ADC filter is enabled by default in OpenTX and is known to cause issues with RC Command data. This can result in \"jagged\" RC command responses in black box logs, caused by sequential RC packets that have the same command value (which were \"smoothed\" by the ADC filter). We recommend turning the ADC filter OFF in OpenTX .","title":"ADC Filter"},{"location":"quick-start/tx-prep/#lua-script","text":"For faster access to the Lua script, save the ELRS.lua File from this link: ExLRS Lua Script onto the radio's SD Card in the Scripts/Tools folder and Long Press the \"SYS\" button (for T16 or similar Radios) or the \"Menu\" button (for Taranis X9D or similar Radios) to access the Tools Menu where you can find ELRS script ready to run with only one click. Another way to get the ELRS Lua Script is via the ExpressLRS Configurator. Here's how it looks in the Tools Menu: Note: For devices not yet flashed with ExpressLRS, the section below will not work. The Lua script has an important feature that's highly valuable with troubleshooting. On the first line, after the 6-character version hash, it shows an indicator 0:nnn which tells you how many bad UART packets and how many good UART packets per second it's getting from the radio. It can be used to confirm the communication between the Radio and the TX module is working properly. e.g. if you have set the Packet Rate to 200Hz, 0:200 means 0 bad packets and 200 good packets. The second number should match the selected packet rate (200 for 200Hz, 500 for 500Hz, etc..) If it doesn't and is stuck at 250 that means CRSFshot isn't working. Go back to the top of this page and verify you've done all the steps above correctly.","title":"Lua Script"},{"location":"quick-start/tx-prep/#troubleshooting-lua-script","text":"\"Connecting\" showing on the Lua Script would mean the Protocol set for the External Module is incorrect or that the module is not properly connected to the pins of the jr bay of the radio. The latter could mean that the module's PCB has gotten loose, common with the first batches of the ES24TX modules from Happymodel. If the number up top the lua script is showing 0:142, etc., have a look at your model settings and make sure the internal RF module is set to off. The \"33e2a6\" from the photo above is the Commit Hash of the firmware version that the module has. You can reference this hash from Releases . If you can't find the commit hash from the Releases page, this could mean you are using firmware from the manufacturer's own fork of the ExpressLRS code. Now that your radio is set, you can now proceed with flashing ExpressLRS!","title":"Troubleshooting Lua Script"},{"location":"quick-start/tx-r9m/","text":"Flashing via OpenTX (Requires OpenTX 2.3.12 or newer) \u00b6 Flashing the Bootloader \u00b6 The bootloader is required to be flashed first prior to flashing the ExpressLRS firmware as the bootloader will replace the factory-bootloader, and enable the hardware to instead use the ExpressLRS code. Using an OpenTX transmitter, you flash the bootloader, and then flash ELRS. Here is a quick 2 minute demo if you would rather watch a video than read the steps: With the previous step ( Preparing your Radio ) done, you should now readily flash your R9 Transmitter Module. Copy r9m_elrs_bl.frk onto the SD card of your radio, in the /FIRMWARE folder. Flash r9m_elrs_bl.frk (14kb) to your TX module: Navigate in OpenTX to the TOOLS menu (hold SYS button) Page to the SD-HC CARD page, then the FIRMWARE folder Flash the frk file by holding OK and selecting \"Flash external module\" Flashing the firmware \u00b6 Targets: Frsky_TX_R9M_via_stock_BL Frsky_TX_R9M_LITE_via_stock_BL Using Build in the ExpressLRS Configurator, wait for the firmware to be compiled. After that's done, ExpressLRS Configurator Log should show the Success Message, and it will automatically open the folder where the firmware.elrs can be found. Put (copy-paste) the firmware.elrs to your Radio's SD Card (preferably to the /FIRMWARE folder for easy access). Once on your radio, navigate to the /FIRMWARE folder, select the firmware.elrs and click-hold the Enter button and select \"Flash External ELRS\". By this point, the bootloader (r9m_elrs_bl.frk) should've been flashed already. Wait for the flashing to finish, and if your module is equipped with a speaker (full size R9Ms), you should hear the tune and two beeps (if external module is now set to CRSF protocol). Flashing using STLink \u00b6 Targets: Frsky_TX_R9M_via_STLINK Frsky_TX_R9M_LITE_via_STLINK Frsky_TX_R9M_LITE_PRO_via_STLINK This method is an irreversible one. You will not be able to go back to Frsky firmwares with this method. You have been warned! This method also involves taking apart your module and soldering wires directly into its board. If you're not comfortable doing this, `STOP' now. Before flashing, disable 'Readout Protection' . To do this download the ST-LINK Utility and follow this quick how to video . After such, you can now disconnect from the ST-Link Utility. R9M STLink Connection R9M Lite STLink Connection R9M Lite Pro STLink Connection With the module connected shown above, and your configuration set, hit Build & Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. The ExpressLRS tune should play and then two beeps after that can be heard, for units that has a speaker (R9Ms) and if the External Module is set to CRSF Protocol. Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.","title":"Flashing Frsky R9 Modules"},{"location":"quick-start/tx-r9m/#flashing-via-opentx-requires-opentx-2312-or-newer","text":"","title":"Flashing via OpenTX (Requires OpenTX 2.3.12 or newer)"},{"location":"quick-start/tx-r9m/#flashing-the-bootloader","text":"The bootloader is required to be flashed first prior to flashing the ExpressLRS firmware as the bootloader will replace the factory-bootloader, and enable the hardware to instead use the ExpressLRS code. Using an OpenTX transmitter, you flash the bootloader, and then flash ELRS. Here is a quick 2 minute demo if you would rather watch a video than read the steps: With the previous step ( Preparing your Radio ) done, you should now readily flash your R9 Transmitter Module. Copy r9m_elrs_bl.frk onto the SD card of your radio, in the /FIRMWARE folder. Flash r9m_elrs_bl.frk (14kb) to your TX module: Navigate in OpenTX to the TOOLS menu (hold SYS button) Page to the SD-HC CARD page, then the FIRMWARE folder Flash the frk file by holding OK and selecting \"Flash external module\"","title":"Flashing the Bootloader"},{"location":"quick-start/tx-r9m/#flashing-the-firmware","text":"Targets: Frsky_TX_R9M_via_stock_BL Frsky_TX_R9M_LITE_via_stock_BL Using Build in the ExpressLRS Configurator, wait for the firmware to be compiled. After that's done, ExpressLRS Configurator Log should show the Success Message, and it will automatically open the folder where the firmware.elrs can be found. Put (copy-paste) the firmware.elrs to your Radio's SD Card (preferably to the /FIRMWARE folder for easy access). Once on your radio, navigate to the /FIRMWARE folder, select the firmware.elrs and click-hold the Enter button and select \"Flash External ELRS\". By this point, the bootloader (r9m_elrs_bl.frk) should've been flashed already. Wait for the flashing to finish, and if your module is equipped with a speaker (full size R9Ms), you should hear the tune and two beeps (if external module is now set to CRSF protocol).","title":"Flashing the firmware"},{"location":"quick-start/tx-r9m/#flashing-using-stlink","text":"Targets: Frsky_TX_R9M_via_STLINK Frsky_TX_R9M_LITE_via_STLINK Frsky_TX_R9M_LITE_PRO_via_STLINK This method is an irreversible one. You will not be able to go back to Frsky firmwares with this method. You have been warned! This method also involves taking apart your module and soldering wires directly into its board. If you're not comfortable doing this, `STOP' now. Before flashing, disable 'Readout Protection' . To do this download the ST-LINK Utility and follow this quick how to video . After such, you can now disconnect from the ST-Link Utility. R9M STLink Connection R9M Lite STLink Connection R9M Lite Pro STLink Connection With the module connected shown above, and your configuration set, hit Build & Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. The ExpressLRS tune should play and then two beeps after that can be heard, for units that has a speaker (R9Ms) and if the External Module is set to CRSF Protocol. Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.","title":"Flashing using STLink"},{"location":"quick-start/tx-siyifm30/","text":"Targets: FM30_TX_via_STLINK (Initial Flash) FM30_TX_via_DFU (Updating) Initial Flash \u00b6 Begin by opening the TX module by removing the 4 screws at the corners using a small phillips screwdriver. Lift the cover from the case and unscrew the antenna holder from the cover. Remove the 2 screws around the edges and remove the PCB module from the case. Solder 4 STLink wires to the JP4 holes (CLK-DIO-RST-GND) and 1 wire to VCC pad as shown: Attach to an STLink as shown: With the module connected shown above, and your configuration set, hit Build & Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying. Updating \u00b6 Plug the FM30 into the USB of your computer. Then select FM30_TX_via_DFU and press Build & Flash to update the TX.","title":"Flashing Siyi FM30"},{"location":"quick-start/tx-siyifm30/#initial-flash","text":"Begin by opening the TX module by removing the 4 screws at the corners using a small phillips screwdriver. Lift the cover from the case and unscrew the antenna holder from the cover. Remove the 2 screws around the edges and remove the PCB module from the case. Solder 4 STLink wires to the JP4 holes (CLK-DIO-RST-GND) and 1 wire to VCC pad as shown: Attach to an STLink as shown: With the module connected shown above, and your configuration set, hit Build & Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.","title":"Initial Flash"},{"location":"quick-start/tx-siyifm30/#updating","text":"Plug the FM30 into the USB of your computer. Then select FM30_TX_via_DFU and press Build & Flash to update the TX.","title":"Updating"},{"location":"quick-start/tx-voyager900/","text":"Flashing via Wifi \u00b6 Target: NamimnoRC_Voyager_900_TX_via_WiFi Method 1 \u00b6 With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the firmware.bin file is. Do not close this window so you can easily locate the correct file to upload to the module. These Tx Modules are STM32-based so they require a separate ESP \"backpack\" device for Wifi Flashing/Updating. The Wifi Update option in the ExpressLRS Lua script will not work with these devices. The steps that follow will be used instead. Attach the module to your JR Bays and power it up. Connect to the ESP Wifi Manager Hotspot that the device will activate. Once connected, navigate to http://elrs_tx.local/ (IP: 192.168.4.1). Press Configure WiFi and set your home network SSID and password. This will enable your Tx Module to connect to your local home network. On your browser, refresh the http://elrs_tx.local/ and scroll towards the STM32 Firmware Update section, as shown below: Drag-and-drop the firmware.bin file created by the ExpressLRS Configurator into the Choose File field, or manually navigate to the Folder by clicking the Choose File button. Once the correct file is selected, click the Upload and Flash STM32 . Wait for the process to complete, and the module will reboot (~2-3min). Using the ELRS.lua script, verify that you have the latest version. Method 2 \u00b6 These Tx Modules are STM32-based so they require a separate ESP \"backpack\" device for Wifi Flashing/Updating. The Wifi Update option in the ExpressLRS Lua script will not work with these devices. The steps that follow will be used instead. Attach the module to your JR Bays and power it up. Connect to the ESP Wifi Manager Hotspot that the device will activate. Once connected, navigate to http://elrs_tx.local/ (IP: 192.168.4.1). Press Configure WiFi and set your home network SSID and password. This will enable your Tx Module to connect to your local home network. Using the ExpressLRS Configurator, select the correct Target and set your Firmware Options . Click Build and Flash and wait for the compile process to complete. You should see a section as pictured below and the Success message marking the update process complete. Using the ELRS.lua script, verify that you have the latest version. Flashing via STLink \u00b6 Target: NamimnoRC_Voyager_900_TX_via_STLINK ONLY USE THIS METHOD IF THE FIRMWARE HAS BEEN CORRUPTED Begin by disassembling the module by unscrewing the 4 screws at the rear of the module with a 1.5mm hex wrench. Carefully seperate the parts of the module and detach the cable from the main PCB. Wire your STLink v2 to the module's pins as show below: With the module connected shown above, and your configuration set, hit Build & Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. If the Radio has CRSF selected, the light should turn green meaning the module has communication with your radio. Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.","title":"Flashing NamimnoRC Voyager"},{"location":"quick-start/tx-voyager900/#flashing-via-wifi","text":"Target: NamimnoRC_Voyager_900_TX_via_WiFi","title":"Flashing via Wifi"},{"location":"quick-start/tx-voyager900/#method-1","text":"With the correct target selected and Firmware Options set, Build your firmware using the ExpressLRS Configurator. Once it's done, it should open the Target folder for you where the firmware.bin file is. Do not close this window so you can easily locate the correct file to upload to the module. These Tx Modules are STM32-based so they require a separate ESP \"backpack\" device for Wifi Flashing/Updating. The Wifi Update option in the ExpressLRS Lua script will not work with these devices. The steps that follow will be used instead. Attach the module to your JR Bays and power it up. Connect to the ESP Wifi Manager Hotspot that the device will activate. Once connected, navigate to http://elrs_tx.local/ (IP: 192.168.4.1). Press Configure WiFi and set your home network SSID and password. This will enable your Tx Module to connect to your local home network. On your browser, refresh the http://elrs_tx.local/ and scroll towards the STM32 Firmware Update section, as shown below: Drag-and-drop the firmware.bin file created by the ExpressLRS Configurator into the Choose File field, or manually navigate to the Folder by clicking the Choose File button. Once the correct file is selected, click the Upload and Flash STM32 . Wait for the process to complete, and the module will reboot (~2-3min). Using the ELRS.lua script, verify that you have the latest version.","title":"Method 1"},{"location":"quick-start/tx-voyager900/#method-2","text":"These Tx Modules are STM32-based so they require a separate ESP \"backpack\" device for Wifi Flashing/Updating. The Wifi Update option in the ExpressLRS Lua script will not work with these devices. The steps that follow will be used instead. Attach the module to your JR Bays and power it up. Connect to the ESP Wifi Manager Hotspot that the device will activate. Once connected, navigate to http://elrs_tx.local/ (IP: 192.168.4.1). Press Configure WiFi and set your home network SSID and password. This will enable your Tx Module to connect to your local home network. Using the ExpressLRS Configurator, select the correct Target and set your Firmware Options . Click Build and Flash and wait for the compile process to complete. You should see a section as pictured below and the Success message marking the update process complete. Using the ELRS.lua script, verify that you have the latest version.","title":"Method 2"},{"location":"quick-start/tx-voyager900/#flashing-via-stlink","text":"Target: NamimnoRC_Voyager_900_TX_via_STLINK ONLY USE THIS METHOD IF THE FIRMWARE HAS BEEN CORRUPTED Begin by disassembling the module by unscrewing the 4 screws at the rear of the module with a 1.5mm hex wrench. Carefully seperate the parts of the module and detach the cable from the main PCB. Wire your STLink v2 to the module's pins as show below: With the module connected shown above, and your configuration set, hit Build & Flash in the ExpressLRS Configurator and wait for the process to finish. Once that's done, and the Success Message showing, you can now remove/unsolder the STLink, and re-assemble the module, and put it into your Radio's Module Bay. If the Radio has CRSF selected, the light should turn green meaning the module has communication with your radio. Verification can be done using the ELRS.lua script. It should show the Version Hash at the top, as well as the options you can set. If it's showing \"Connecting\", check if External Module is set to CRSF for the selected model in your radio, and that internal RF module is set to off. See general Troubleshooting section for other ways to determine your module is flashed and ready for flying.","title":"Flashing via STLink"},{"location":"software/obsolete-defines/","text":"This page contains old user_defines.txt that have been removed or superseded by new defines. New items should be added to the top of the list so the last entry here is the oldest. The order of each entry should be [code]definename[/code] followed by the original text of the documentation, ending with a separate paragraph \" REMOVED [version] [replacement or reason for removal]\". Obsolete Defines \u00b6 -DFAST_SYNC Option that adds faster initial syncing, by changing how long the receiver waits for a connection in each mode while not connected. This option is now the default, but disabling it can help syncing at lower packet rates (50Hz and below). REMOVED 1.0.0-RC2 initial sync replaced with a full FHSS period wait #-DR9M_UNLOCK_HIGHER_POWER REMOVED 1.0.0-RC1 replaced with generic -DUNLOCK_HIGHER_POWER #-DARM_CHANNEL=AUX1 If you are using a different channel than the default you need to edit \ud83d\udd25 (or you may not be able to gain sync safely - default is listed in #DARM_CHANNEL as AUX1 which is Channel 5). NB This feature assumes that a low value of the arm switch is disarmed, and a high value is armed. If you have the arm switch reversed it will not work correctly and the link won't be established. For this reason it may be best not to enable no sync on arm when you are first setting up ExpressLRS as it can be a source of confusion. REMOVED 1.0.0-RC1 AUX1 is always the arm switch now, no longer configurable #-DLOCK_ON_50HZ LOCK_ON_50HZ locks the RX at 50Hz mode from the powerup. (Only recommended for longrange, and partly redundant with previous feature.) Merged in Pull 143 REMOVED 1.0.0-RC1 not sure why this was removed -DAUTO_WIFI_ON_BOOT REMOVED 1.0.0-RC1 replaced with -DAUTO_WIFI_ON_INTERVAL=X","title":"Obsolete Defines"},{"location":"software/obsolete-defines/#obsolete-defines","text":"-DFAST_SYNC Option that adds faster initial syncing, by changing how long the receiver waits for a connection in each mode while not connected. This option is now the default, but disabling it can help syncing at lower packet rates (50Hz and below). REMOVED 1.0.0-RC2 initial sync replaced with a full FHSS period wait #-DR9M_UNLOCK_HIGHER_POWER REMOVED 1.0.0-RC1 replaced with generic -DUNLOCK_HIGHER_POWER #-DARM_CHANNEL=AUX1 If you are using a different channel than the default you need to edit \ud83d\udd25 (or you may not be able to gain sync safely - default is listed in #DARM_CHANNEL as AUX1 which is Channel 5). NB This feature assumes that a low value of the arm switch is disarmed, and a high value is armed. If you have the arm switch reversed it will not work correctly and the link won't be established. For this reason it may be best not to enable no sync on arm when you are first setting up ExpressLRS as it can be a source of confusion. REMOVED 1.0.0-RC1 AUX1 is always the arm switch now, no longer configurable #-DLOCK_ON_50HZ LOCK_ON_50HZ locks the RX at 50Hz mode from the powerup. (Only recommended for longrange, and partly redundant with previous feature.) Merged in Pull 143 REMOVED 1.0.0-RC1 not sure why this was removed -DAUTO_WIFI_ON_BOOT REMOVED 1.0.0-RC1 replaced with -DAUTO_WIFI_ON_INTERVAL=X","title":"Obsolete Defines"},{"location":"software/open-ocd/","text":"If you are using linux then you can't use the ST-LINK utility from st.com. But fortunately you can achieve the same effect with openocd on the linux command line. This tutorial assumes you have an STLink v2 install openocd from your distro's repository. for debian/ubuntu use: sudo apt-get install openocd change directories to openocd script repository: cd /usr/share/openocd issue the full command: openocd -f ./scripts/interface/stlink-v2.cfg -f ./scripts/target/stm32f1x.cfg -c \"init; reset halt; stm32f1x unlock 0; reset run; shutdown\" restart your device so the disabled readout protection can take effect. Now you can proceed with flashing your R9m or R9MM. this may work on other frsky devices or it might not.","title":"OpenOCD for STLink"},{"location":"software/stlink-fix/","text":"PlatformIO has an older version of STLink. It is unable to communicate with the STM32L MCUs on some Rx's. Affected RX's: -(DIY) PP Swapping out PIO's STLink folder contents with the current STLink will allow using the configurator with these RX's. Go to your STLink folder copy contents of \"ST-Link Utility\" C:\\Program Files (x86)\\STMicroelectronics\\STM32 ST-LINK Utility\\ST-LINK Utility paste files from \"st-link utility\" folder into \"stlink\" folder in your users PIO location C:\\Users\\username\\ .platformio\\packages\\tool-stm32duino","title":"PIO STLink Fix"},{"location":"software/switch-config/","text":"This documentation applies to versions above 1.0.0-RC1 Put your arm switch on AUX1 ExpressLRS has two options for how switches are transmitted: Normal mode and HYBRID_SWITCHES_8 . The switch mode selected MUST match (select either Option 1 or Option 2) between the TX module and RX. The default choice is to have 8x 2-position switches. \ud83e\udd48 That's really about all there is to this mode, other than noting that you should have your arm switch on AUX1. ExpressLRS uses AUX1 to determine if your model is armed. Channel Resolution Frequency AUX1 1-bit / 2-position Every packet, ARM channel AUX2-AUX8 1-bit / 2-position Every packet The other option is HYBRID_SWITCHES_8 where the switches are broken into different types Channel Resolution Frequency AUX1 1-bit / 2-position Every packet, ARM channel AUX2-AUX7 3-bit / 2-position, 3-position, or 6-position Round-robin AUX8 4-bit / 16-position Round-robin The first switch (AUX1) is sent with every packet. Put. Your. Arm. On. AUX1. For the remaining 7 switches, one switch is sent with each packet (in addition to AUX1). When a switch changes, it is given priority to be sent in the next packet to try to reduce its latency. AUX 1 \u00b6 Put your arm switch on AUX1 . AUX1 is the low-latency switch, sent with every packet, and only supports on/off (2-position) operation. ExpressLRS uses AUX1 to determine if your model is armed, and should set up on the transmitter so that ~1000 is disarmed, ~2000 is armed. AUX 2-7 \u00b6 The majority of the aux channels, AUX2 - AUX7, work with 2-position switches, 3-position switches, or 6-position switches / selector buttons. Approx. Channel Input (us) Channel Output (us) Ardupilot Mode 988 1000 Mode1 (up position for 2-pos / 3-pos) 1192 1275 Mode2 1398 1425 Mode3 1500 1500 Mode4 (center position in 3-pos) 1602 1575 Mode4 1807 1725 Mode5 2011 2000 Mode6 (down position for 2-pos / 3-pos) AUX 8 \u00b6 AUX8 is the wide range channel, supporting 16 positions. You can stack all your modes in here, Bardwell style, or get some low-res camera pan action-- 180 degrees / 16 actually isn't terrible. Clever math-heads might note that there's no \"center position\" (1500us) in a 16-position switch, so using AUX8 with a 3-position switch means it will come out as 1533 at the flight controller. Switch Position Channel Output (us) Switch Position Channel Output (us) 0 1000 8 1533 1 1066 9 1600 2 1133 10 1666 3 1200 11 1733 4 1266 12 1800 5 1333 13 1866 6 1400 14 1933 7 1467 15 2000 FAQ \u00b6 Why do you keep saying \" put arm on AUX1 \"? \u00b6 For safety reasons. In HYBRID_SWITCHES_8 mode, AUX1 is sent with every packet going out, this is the most reliable way to be able to tell your model to disarm. If your arm switch is in another aux channel, it may be several packets before that switch is transmitted, and there's no guarantee that the RX will actually receive that packet. There's a non-trivial chance your model may not ever disarm if the link quality is low and it just so happens that the packet containing the arm switch is getting missed every time. Forcing the arm switch into every packet on AUX1 means that if any packet is received by ExpresLRS, it will disarm your model, not just a less than 1-in-7 chance. It also protects against unintentional disarms caused by a corrupt packet changing the value of the arm switch to disarmed. Betaflight requires that 4x \"disarm\" commands are received before disarming to guard against this possibility. With arm on AUX1, a single corrupt packet can not disarm your model. With arm on AUX2-8, the one corrupt switch value will be sent 6 times before the value is refreshed, but the flight controller would have already disarmed by that point. I use a 3-pos switch for arm, this software is unusable \u00b6 You can still use a 3-position switch to arm! AUX1 just needs to be 2-position, not the physical switch. Simply adjust the mixer in your transmitter so AUX1 works like an on-off switch. If your 3-position arm switch had a second function as well, such as enabling Blackbox, just use one of the other 7 AUX channels to send the switch on a second channel. Why can't I have switches / potentiometers with full 10-bit resolution? \u00b6 A lot of the magic of ExpressLRS comes from its small packet sizes, there simply is not enough space to put all that data. There are tricks that can be done with interleaving sticks and switches packets but we believe sticks should be in every packet for the lowest control latency. Different switch modes with higher resolution may be added further down the road for setups where higher latency doesn't matter.","title":"Switch Configs"},{"location":"software/switch-config/#aux-1","text":"Put your arm switch on AUX1 . AUX1 is the low-latency switch, sent with every packet, and only supports on/off (2-position) operation. ExpressLRS uses AUX1 to determine if your model is armed, and should set up on the transmitter so that ~1000 is disarmed, ~2000 is armed.","title":"AUX 1"},{"location":"software/switch-config/#aux-2-7","text":"The majority of the aux channels, AUX2 - AUX7, work with 2-position switches, 3-position switches, or 6-position switches / selector buttons. Approx. Channel Input (us) Channel Output (us) Ardupilot Mode 988 1000 Mode1 (up position for 2-pos / 3-pos) 1192 1275 Mode2 1398 1425 Mode3 1500 1500 Mode4 (center position in 3-pos) 1602 1575 Mode4 1807 1725 Mode5 2011 2000 Mode6 (down position for 2-pos / 3-pos)","title":"AUX 2-7"},{"location":"software/switch-config/#aux-8","text":"AUX8 is the wide range channel, supporting 16 positions. You can stack all your modes in here, Bardwell style, or get some low-res camera pan action-- 180 degrees / 16 actually isn't terrible. Clever math-heads might note that there's no \"center position\" (1500us) in a 16-position switch, so using AUX8 with a 3-position switch means it will come out as 1533 at the flight controller. Switch Position Channel Output (us) Switch Position Channel Output (us) 0 1000 8 1533 1 1066 9 1600 2 1133 10 1666 3 1200 11 1733 4 1266 12 1800 5 1333 13 1866 6 1400 14 1933 7 1467 15 2000","title":"AUX 8"},{"location":"software/switch-config/#faq","text":"","title":"FAQ"},{"location":"software/switch-config/#why-do-you-keep-saying-put-arm-on-aux1","text":"For safety reasons. In HYBRID_SWITCHES_8 mode, AUX1 is sent with every packet going out, this is the most reliable way to be able to tell your model to disarm. If your arm switch is in another aux channel, it may be several packets before that switch is transmitted, and there's no guarantee that the RX will actually receive that packet. There's a non-trivial chance your model may not ever disarm if the link quality is low and it just so happens that the packet containing the arm switch is getting missed every time. Forcing the arm switch into every packet on AUX1 means that if any packet is received by ExpresLRS, it will disarm your model, not just a less than 1-in-7 chance. It also protects against unintentional disarms caused by a corrupt packet changing the value of the arm switch to disarmed. Betaflight requires that 4x \"disarm\" commands are received before disarming to guard against this possibility. With arm on AUX1, a single corrupt packet can not disarm your model. With arm on AUX2-8, the one corrupt switch value will be sent 6 times before the value is refreshed, but the flight controller would have already disarmed by that point.","title":"Why do you keep saying \"put arm on AUX1\"?"},{"location":"software/switch-config/#i-use-a-3-pos-switch-for-arm-this-software-is-unusable","text":"You can still use a 3-position switch to arm! AUX1 just needs to be 2-position, not the physical switch. Simply adjust the mixer in your transmitter so AUX1 works like an on-off switch. If your 3-position arm switch had a second function as well, such as enabling Blackbox, just use one of the other 7 AUX channels to send the switch on a second channel.","title":"I use a 3-pos switch for arm, this software is unusable"},{"location":"software/switch-config/#why-cant-i-have-switches-potentiometers-with-full-10-bit-resolution","text":"A lot of the magic of ExpressLRS comes from its small packet sizes, there simply is not enough space to put all that data. There are tricks that can be done with interleaving sticks and switches packets but we believe sticks should be in every packet for the lowest control latency. Different switch modes with higher resolution may be added further down the road for setups where higher latency doesn't matter.","title":"Why can't I have switches / potentiometers with full 10-bit resolution?"},{"location":"software/toolchain-install/","text":"Note: The following section is intended for advanced users who intend to dabble with the source code directly. Toolchain Setup (Advanced) \u00b6 ExpressLRS is written in C++ using the Arduino framework. Rather than using the Arduino IDE (which let's face it, \ud83d\uddff is pretty clunky), we use platformio To ease the use of pio we recommend to use the according extension for Visual Studio Code PlatformIO \u00b6 \ud83d\udd3d Download a copy of vscode for your computer \ud83d\udcc2 Open vscode, and click on the \" Extensions \" icon in the toolbar on the right (see Managing Extensions \ud83d\udcd8) \ud83d\udd0e In the search box, enter platformio , and install the extension (see the pio install documentation \ud83d\udcda) Git Setup \u00b6 We recommend using VSCode's built-in Git client, as it requires the least 3 rd party software \ud83e\udd16. \ud83d\udd3d Download a copy of git (this is also needed for PlatformIO ) Install git , click yes to the default options (there are a LOT \ud83d\udcaf) IMPORTANT! Make sure you select this option during install, it adds git to PATH which is necessary for VScode cloning (the next step). Cloning the Repo \u00b6 In VSCode open the command pallete (using Cmd+Shift+P on MacOS or Ctrl+Shift+P on Windows) Enter Git: Clone Click that! \ud83d\udc48 Then, enter ExpressLRS Repo URL -> https://github.com/AlessandroAU/ExpressLRS.git \ud83d\udcbb Choose a folder for ExpressLRS. \ud83d\udcc2 Selecting the Latest Release \u00b6 Before we can do any building, you need to select a release build of ELRS. For example, release 0.1.0-RC1 . In Visual Studio Code select that tag. The location of the selector is shown below. \ud83d\uddb1\ufe0f Click the selector, and then type in the name of the tag, in this case 0.1.0-RC1 . PlatformIO Building \u00b6 Once you had the time of your life setting up your toolchain \ud83e\uddf0 you are ready to Flash \u26a1 ExpressLRS to supported hardware . Building Targets using PlatformIO \u00b6 \ud83d\udcc2 When you first launch Visual Studio Code , you should see the PlatformIO Home Page in a tab. Click the Open Project button. Navigate to the ExpressLRS repo directory. Navigate into the src folder (i.e. ./ExpressLRS/src/ ). Finally, press the Open button. \u270f\ufe0f Edit the file ./src/user_defines.txt to define user specific variabls. \ud83d\ude08 Please make sure you did edit the file according to your needs! \ud83d\udcca In the toolbar on the left, click the PlatformIO icon, which will show the list of tasks. Now, select Project Tasks, expand your desired target and select Build/Upload (depending on the method). You should see the result in the terminal. \ud83d\ude43 If something went wrong - please check the Terminal , too. It will contain at least a hint on what the issue is. Please ask the community for further help\ud83e\uddd1\u200d\ud83d\udd27!","title":"Toolchain Setup"},{"location":"software/toolchain-install/#toolchain-setup-advanced","text":"ExpressLRS is written in C++ using the Arduino framework. Rather than using the Arduino IDE (which let's face it, \ud83d\uddff is pretty clunky), we use platformio To ease the use of pio we recommend to use the according extension for Visual Studio Code","title":"Toolchain Setup (Advanced)"},{"location":"software/toolchain-install/#platformio","text":"\ud83d\udd3d Download a copy of vscode for your computer \ud83d\udcc2 Open vscode, and click on the \" Extensions \" icon in the toolbar on the right (see Managing Extensions \ud83d\udcd8) \ud83d\udd0e In the search box, enter platformio , and install the extension (see the pio install documentation \ud83d\udcda)","title":"PlatformIO"},{"location":"software/toolchain-install/#git-setup","text":"We recommend using VSCode's built-in Git client, as it requires the least 3 rd party software \ud83e\udd16. \ud83d\udd3d Download a copy of git (this is also needed for PlatformIO ) Install git , click yes to the default options (there are a LOT \ud83d\udcaf) IMPORTANT! Make sure you select this option during install, it adds git to PATH which is necessary for VScode cloning (the next step).","title":"Git Setup"},{"location":"software/toolchain-install/#cloning-the-repo","text":"In VSCode open the command pallete (using Cmd+Shift+P on MacOS or Ctrl+Shift+P on Windows) Enter Git: Clone Click that! \ud83d\udc48 Then, enter ExpressLRS Repo URL -> https://github.com/AlessandroAU/ExpressLRS.git \ud83d\udcbb Choose a folder for ExpressLRS. \ud83d\udcc2","title":"Cloning the Repo"},{"location":"software/toolchain-install/#selecting-the-latest-release","text":"Before we can do any building, you need to select a release build of ELRS. For example, release 0.1.0-RC1 . In Visual Studio Code select that tag. The location of the selector is shown below. \ud83d\uddb1\ufe0f Click the selector, and then type in the name of the tag, in this case 0.1.0-RC1 .","title":"Selecting the Latest Release"},{"location":"software/toolchain-install/#platformio-building","text":"Once you had the time of your life setting up your toolchain \ud83e\uddf0 you are ready to Flash \u26a1 ExpressLRS to supported hardware .","title":"PlatformIO Building"},{"location":"software/toolchain-install/#building-targets-using-platformio","text":"\ud83d\udcc2 When you first launch Visual Studio Code , you should see the PlatformIO Home Page in a tab. Click the Open Project button. Navigate to the ExpressLRS repo directory. Navigate into the src folder (i.e. ./ExpressLRS/src/ ). Finally, press the Open button. \u270f\ufe0f Edit the file ./src/user_defines.txt to define user specific variabls. \ud83d\ude08 Please make sure you did edit the file according to your needs! \ud83d\udcca In the toolbar on the left, click the PlatformIO icon, which will show the list of tasks. Now, select Project Tasks, expand your desired target and select Build/Upload (depending on the method). You should see the result in the terminal. \ud83d\ude43 If something went wrong - please check the Terminal , too. It will contain at least a hint on what the issue is. Please ask the community for further help\ud83e\uddd1\u200d\ud83d\udd27!","title":"Building Targets using PlatformIO"},{"location":"software/user-defines/","text":"User Defines Explained \u00b6 With more features being added consistently, ./src/user_defines.txt has gotten complicated \ud83e\udd37\u200d\u2642\ufe0f. So we will break it down! \ud83d\udd28 *Note: This is the full list of currently supported User Defines and would help you should you intend to compile the firmware using the Toolchain . Defines 101 \u00b6 To enable/disable anything in the user defines, simply add or remove a # in front of anything that has a -D . We recommend reading this page in its entirety before first flashing \u26a1 to have a better sense of the options. Binding Phrase \u00b6 -DMY_BINDING_PHRASE=\"default ExpressLRS binding phrase\" This step is simple but important . Both the TX and RX NEED to have the same binding phrase or ExpressLRS WILL NOT WORK . Anyone using the same binding phrase as you will be able to control your model, so be unique. Set something memorable, and limit to alphanumeric phrases conforming to the Latin alphabet. Receivers flashed with firmware builds that do not have binding phrase enabled will support and require the traditional binding method. \ud83d\udcdc This phrase gets md5 hashed and gets built into the binary you will be flashing. Regulatory Domain \u00b6 #-DRegulatory_Domain_AU_915 #-DRegulatory_Domain_EU_868 #-DRegulatory_Domain_AU_433 #-DRegulatory_Domain_EU_433 #-DRegulatory_Domain_FCC_915 #-DRegulatory_Domain_ISM_2400 This is a relatively simple one - enable whatever regulatory domain you are in. EU 868 \ud83c\uddea\ud83c\uddfa is compliant to the frequency but is not LBT compliant \ud83d\udc42 . Every other band is near compliant \ud83d\udc7f but may not be fully compliant for your regulatory domain. Telemetry \u00b6 #-DENABLE_TELEMETRY Enable advanced telemetry support. This option must be enabled on both TX and RX . The following telemetry messages are supported: GPS BATTERY_SENSOR ATTITUDE DEVICE_INFO FLIGHT_MODE MSP_RESP Note #1 : Increase the telemetry rate with the ExpressLRS lua script. Increase the rate until the sensor lost warnings go away. It is normal to set it up to 1:16 with 200 Hz refresh rate. Note #2 : It must be enabled together with HYBRID_SWITCHES_8 . #-DTLM_REPORT_INTERVAL_MS=320LU It makes the TX module send the telemetry data to the OpenTX every 320 ms by default. This stops the telemetry lost warnings when running a high telemetry ratio, or low rates like 50hz. Default value is 320LU . If you want to change that you have to suffix your milliseconds value with LU . For example, in order to specify 100 ms telemetry update rate you have to enter it like this: 100LU . Typically, you want to keep 320LU value for OpenTX based radios, and 100LU for ErskyTx ones. Switches \u00b6 #-DHYBRID_SWITCHES_8 Changes how the AUX channels are sent over the air. The default option is Normal Mode with 8x 2-position low-latency switches. Enabling HYBRID_SWITCHES_8 changes this to 1x 2-pos + 6x 7-pos + 1x 16-pos, with only the 2-position being low-latency. In Normal Mode, all switches are sent with every packet, in Hybrid Mode, only AUX1 is sent with every packet and the rest are rotated through. Note: The switch mode MUST match between the RX and TX. A detailed explanation of the differences between the two options can be found in Switch Modes , but 1. If only two position switches are needed, and they must be updated as fast as possible: Normal Mode 2. Almost everyone: Hybrid Mode (Put ARM on AUX1) Output Power Limit \u00b6 There has been some reports of the R9M modules showing instability at >250mw with stock cooling. This in part because the ELRS uses a higher duty cycle for transmission compared to stock firmware. By default the power of any TX is limited to 250mw but you can unlock up to 1000mw (for hardware that supports it) by enabling the following option. Do this at your own risk if you make no cooling modifications-- R9M modules will burn themselves out without cooling. #-DUNLOCK_HIGHER_POWER We published R9M Fan Mod Cover , a custom 3d printed backplate with room for a fan and extra cooling to allow for maximum power (1-2W depending on the mod). Performance Options \u00b6 #-DNO_SYNC_ON_ARM no sync on arm doesn't transmit sync packets while armed. This is useful for racing as there is less time & packets wasted \ud83d\uddd1\ufe0f on sending sync packets. HOWEVER if you are doing serious long range \u26f0\ufe0f, keep this commented because in the case of a sustained failsafe, link can not be regained while armed. AUX1 is the channel ExpressLRS uses to detect \"ARMED\", and this feature assumes that a low value of the arm switch is disarmed, and a high value is armed . OpenTX can invert your switch if you prefer it to be mechanically inverted. It may be best not to enable no sync on arm when you are first setting up ExpressLRS as it can be a source of confusion. -DFEATURE_OPENTX_SYNC #-DFEATURE_OPENTX_SYNC_AUTOTUNE These features enable lower latency \ud83c\udfc3\u200d\u2642\ufe0f and offset from the OpenTX radio to the TX. The first lowers latency and should be kept enabled. The second is more experimental and can lower the offset from the radio by tuning it as close as possible to 0 , but is experimental (even in 1.0) and is best left disabled. Both require OpenTX 2.3.12 or above. In order to install it, you will have to use OpenTX companion application. -DLOCK_ON_FIRST_CONNECTION RF Mode Locking - When the RX is waiting for a connection, it cycles through all available rates waiting for a connection on each one. By default, ExpressLRS will go back to this mode after a disconnect (failsafe). If LOCK_ON_FIRST_CONNECTION is used, ELRS will not cycle after a disconnect, but instead just stay on whatever rate the last connection was. This makes connection re-establishment quick, because the RX is always listening at the proper rate. This is generally what everyone wants, but there is utility in being able to switch the TX to the lowest rate to get more range to re-establish a link with a downed model, which can't happen if the RX is locked at the previous rate. When cycling through the rates, the RX starts with the fastest packet rate and works down to the slowest, then repeats. It waits PACKET_INTERVAL * PACKS_PER_HOP * HOP_COUNT * 1.1 at each rate. Example: 4ms * 4 * 80 * 1.1 = 1.408s for 250Hz. The duration is extended 10x if a valid packet is received during that time. Even with LOCK_ON_FIRST_CONNECTION , the rate can be changed by changing the TX rate using ELRS.lua while connected, or by power cycling the RX. #-DUSE_DIVERSITY Enable antenna-switching diversity for RX that support it. Compatability Options \u00b6 -DUART_INVERTED This only works with ESP32 based TXes (will not work with modules without built-in inversion/uninversion), but enables compatibility with radios that output inverted CRSF, such as the FrSky QX7, TBS Tango 2, RadioMaster TX16S. You want to keep this enabled in most of the cases. If your radio is T8SG V2 or you use Deviation firmware turn this setting off. -DUSE_UART2 This enables integration with Jye's FENIX rx5805 pro-diversity module \ud83d\udc77 #-DUSE_R9MM_R9MINI_SBUS This does not turn on SBUS protocol it simply changes the pin used for communication from those two side pins (A9 and A10) to use the pin labeled \"SBUS\" on the RX, which is inverted. This is useful for F4 FCs which only have an inverted receiver input UART RX. \ud83d\udd3c. This is only one way, so you lose the telemetry downlink to your radio as well as passthrough flashing. Enabling this turns on CRSF protocol output on the S.BUS \ud83d\ude8c pin on your R9MM/R9Mini . set serialrx_inverted = ON may also be needed within Betaflight \ud83d\udc1d for compatibility Other Options \u00b6 -DAUTO_WIFI_ON_INTERVAL=30 \u26a0\ufe0f Must be defined if you plan to update your RX over wifi without using a button on the RX \u26a0\ufe0f This will automatically turn the wifi \ud83d\udcf6 on for any module that has an ESP8285 on it if no TX connection is established after N seconds from boot (the 30 is the time). This enables pushing firmware updates to the RX by connecting to its wifi network and visiting http://10.0.0.1 . #-DJUST_BEEP_ONCE #-DMY_STARTUP_MELODY=\"<music string>|<bpm>|<semitone offset>\" -or- #-DMY_STARTUP_MELODY=\"<rtttl string>\" For TXes like the R9M, this sets if the TX only beeps one-time versus playing a startup song. Currently, it is set to play the startup song \ud83c\udfbc , but if you don't prefer it, uncomment this to turn it off. \u2716\ufe0f For all your customization needs, use DMY_STARTUP_MELODY to define your own startup melody using the BlHeli32 or RTTTL syntax. For BLHeli32, the parameters music string and bpm are required, whereas semitone offset is optional to transpose the entire melody up or down by the defined amount of semitones. Example BlHeli32 melodies are available on Rox Wolfs youtube channel , some experimentation may be required though. To write your own melody, this (Sheet Music 101) and this (BLHeli Piano) are useful resources. The build process also supports RTTTL-formatted ringtone strings. RTTTL melodies are delimited by colons : and start with a description versus the BLHeli style with have pipes | . e.g. Mario:d=4,o=5,b=100:32p,16e6,16e6,16p,16e6,16p,16c6,16e6,16p,16g6,8p,16p,16g -DUSE_ESP8266_BACKPACK This enables communication with the ESP Backpack for over-the-air updates ( env:FrSky_TX_R9M_via_WiFi ) \ud83d\udda5\ufe0f and debugging via WebSocket \ud83d\udd0d. Uncommented by default, does not need to be changed. Obsolete user_defines \u00b6 See Obsolete user_defines","title":"User Defines"},{"location":"software/user-defines/#user-defines-explained","text":"With more features being added consistently, ./src/user_defines.txt has gotten complicated \ud83e\udd37\u200d\u2642\ufe0f. So we will break it down! \ud83d\udd28 *Note: This is the full list of currently supported User Defines and would help you should you intend to compile the firmware using the Toolchain .","title":"User Defines Explained"},{"location":"software/user-defines/#defines-101","text":"To enable/disable anything in the user defines, simply add or remove a # in front of anything that has a -D . We recommend reading this page in its entirety before first flashing \u26a1 to have a better sense of the options.","title":"Defines 101"},{"location":"software/user-defines/#binding-phrase","text":"-DMY_BINDING_PHRASE=\"default ExpressLRS binding phrase\" This step is simple but important . Both the TX and RX NEED to have the same binding phrase or ExpressLRS WILL NOT WORK . Anyone using the same binding phrase as you will be able to control your model, so be unique. Set something memorable, and limit to alphanumeric phrases conforming to the Latin alphabet. Receivers flashed with firmware builds that do not have binding phrase enabled will support and require the traditional binding method. \ud83d\udcdc This phrase gets md5 hashed and gets built into the binary you will be flashing.","title":"Binding Phrase"},{"location":"software/user-defines/#regulatory-domain","text":"#-DRegulatory_Domain_AU_915 #-DRegulatory_Domain_EU_868 #-DRegulatory_Domain_AU_433 #-DRegulatory_Domain_EU_433 #-DRegulatory_Domain_FCC_915 #-DRegulatory_Domain_ISM_2400 This is a relatively simple one - enable whatever regulatory domain you are in. EU 868 \ud83c\uddea\ud83c\uddfa is compliant to the frequency but is not LBT compliant \ud83d\udc42 . Every other band is near compliant \ud83d\udc7f but may not be fully compliant for your regulatory domain.","title":"Regulatory Domain"},{"location":"software/user-defines/#telemetry","text":"#-DENABLE_TELEMETRY Enable advanced telemetry support. This option must be enabled on both TX and RX . The following telemetry messages are supported: GPS BATTERY_SENSOR ATTITUDE DEVICE_INFO FLIGHT_MODE MSP_RESP Note #1 : Increase the telemetry rate with the ExpressLRS lua script. Increase the rate until the sensor lost warnings go away. It is normal to set it up to 1:16 with 200 Hz refresh rate. Note #2 : It must be enabled together with HYBRID_SWITCHES_8 . #-DTLM_REPORT_INTERVAL_MS=320LU It makes the TX module send the telemetry data to the OpenTX every 320 ms by default. This stops the telemetry lost warnings when running a high telemetry ratio, or low rates like 50hz. Default value is 320LU . If you want to change that you have to suffix your milliseconds value with LU . For example, in order to specify 100 ms telemetry update rate you have to enter it like this: 100LU . Typically, you want to keep 320LU value for OpenTX based radios, and 100LU for ErskyTx ones.","title":"Telemetry"},{"location":"software/user-defines/#switches","text":"#-DHYBRID_SWITCHES_8 Changes how the AUX channels are sent over the air. The default option is Normal Mode with 8x 2-position low-latency switches. Enabling HYBRID_SWITCHES_8 changes this to 1x 2-pos + 6x 7-pos + 1x 16-pos, with only the 2-position being low-latency. In Normal Mode, all switches are sent with every packet, in Hybrid Mode, only AUX1 is sent with every packet and the rest are rotated through. Note: The switch mode MUST match between the RX and TX. A detailed explanation of the differences between the two options can be found in Switch Modes , but 1. If only two position switches are needed, and they must be updated as fast as possible: Normal Mode 2. Almost everyone: Hybrid Mode (Put ARM on AUX1)","title":"Switches"},{"location":"software/user-defines/#output-power-limit","text":"There has been some reports of the R9M modules showing instability at >250mw with stock cooling. This in part because the ELRS uses a higher duty cycle for transmission compared to stock firmware. By default the power of any TX is limited to 250mw but you can unlock up to 1000mw (for hardware that supports it) by enabling the following option. Do this at your own risk if you make no cooling modifications-- R9M modules will burn themselves out without cooling. #-DUNLOCK_HIGHER_POWER We published R9M Fan Mod Cover , a custom 3d printed backplate with room for a fan and extra cooling to allow for maximum power (1-2W depending on the mod).","title":"Output Power Limit"},{"location":"software/user-defines/#performance-options","text":"#-DNO_SYNC_ON_ARM no sync on arm doesn't transmit sync packets while armed. This is useful for racing as there is less time & packets wasted \ud83d\uddd1\ufe0f on sending sync packets. HOWEVER if you are doing serious long range \u26f0\ufe0f, keep this commented because in the case of a sustained failsafe, link can not be regained while armed. AUX1 is the channel ExpressLRS uses to detect \"ARMED\", and this feature assumes that a low value of the arm switch is disarmed, and a high value is armed . OpenTX can invert your switch if you prefer it to be mechanically inverted. It may be best not to enable no sync on arm when you are first setting up ExpressLRS as it can be a source of confusion. -DFEATURE_OPENTX_SYNC #-DFEATURE_OPENTX_SYNC_AUTOTUNE These features enable lower latency \ud83c\udfc3\u200d\u2642\ufe0f and offset from the OpenTX radio to the TX. The first lowers latency and should be kept enabled. The second is more experimental and can lower the offset from the radio by tuning it as close as possible to 0 , but is experimental (even in 1.0) and is best left disabled. Both require OpenTX 2.3.12 or above. In order to install it, you will have to use OpenTX companion application. -DLOCK_ON_FIRST_CONNECTION RF Mode Locking - When the RX is waiting for a connection, it cycles through all available rates waiting for a connection on each one. By default, ExpressLRS will go back to this mode after a disconnect (failsafe). If LOCK_ON_FIRST_CONNECTION is used, ELRS will not cycle after a disconnect, but instead just stay on whatever rate the last connection was. This makes connection re-establishment quick, because the RX is always listening at the proper rate. This is generally what everyone wants, but there is utility in being able to switch the TX to the lowest rate to get more range to re-establish a link with a downed model, which can't happen if the RX is locked at the previous rate. When cycling through the rates, the RX starts with the fastest packet rate and works down to the slowest, then repeats. It waits PACKET_INTERVAL * PACKS_PER_HOP * HOP_COUNT * 1.1 at each rate. Example: 4ms * 4 * 80 * 1.1 = 1.408s for 250Hz. The duration is extended 10x if a valid packet is received during that time. Even with LOCK_ON_FIRST_CONNECTION , the rate can be changed by changing the TX rate using ELRS.lua while connected, or by power cycling the RX. #-DUSE_DIVERSITY Enable antenna-switching diversity for RX that support it.","title":"Performance Options"},{"location":"software/user-defines/#compatability-options","text":"-DUART_INVERTED This only works with ESP32 based TXes (will not work with modules without built-in inversion/uninversion), but enables compatibility with radios that output inverted CRSF, such as the FrSky QX7, TBS Tango 2, RadioMaster TX16S. You want to keep this enabled in most of the cases. If your radio is T8SG V2 or you use Deviation firmware turn this setting off. -DUSE_UART2 This enables integration with Jye's FENIX rx5805 pro-diversity module \ud83d\udc77 #-DUSE_R9MM_R9MINI_SBUS This does not turn on SBUS protocol it simply changes the pin used for communication from those two side pins (A9 and A10) to use the pin labeled \"SBUS\" on the RX, which is inverted. This is useful for F4 FCs which only have an inverted receiver input UART RX. \ud83d\udd3c. This is only one way, so you lose the telemetry downlink to your radio as well as passthrough flashing. Enabling this turns on CRSF protocol output on the S.BUS \ud83d\ude8c pin on your R9MM/R9Mini . set serialrx_inverted = ON may also be needed within Betaflight \ud83d\udc1d for compatibility","title":"Compatability Options"},{"location":"software/user-defines/#other-options","text":"-DAUTO_WIFI_ON_INTERVAL=30 \u26a0\ufe0f Must be defined if you plan to update your RX over wifi without using a button on the RX \u26a0\ufe0f This will automatically turn the wifi \ud83d\udcf6 on for any module that has an ESP8285 on it if no TX connection is established after N seconds from boot (the 30 is the time). This enables pushing firmware updates to the RX by connecting to its wifi network and visiting http://10.0.0.1 . #-DJUST_BEEP_ONCE #-DMY_STARTUP_MELODY=\"<music string>|<bpm>|<semitone offset>\" -or- #-DMY_STARTUP_MELODY=\"<rtttl string>\" For TXes like the R9M, this sets if the TX only beeps one-time versus playing a startup song. Currently, it is set to play the startup song \ud83c\udfbc , but if you don't prefer it, uncomment this to turn it off. \u2716\ufe0f For all your customization needs, use DMY_STARTUP_MELODY to define your own startup melody using the BlHeli32 or RTTTL syntax. For BLHeli32, the parameters music string and bpm are required, whereas semitone offset is optional to transpose the entire melody up or down by the defined amount of semitones. Example BlHeli32 melodies are available on Rox Wolfs youtube channel , some experimentation may be required though. To write your own melody, this (Sheet Music 101) and this (BLHeli Piano) are useful resources. The build process also supports RTTTL-formatted ringtone strings. RTTTL melodies are delimited by colons : and start with a description versus the BLHeli style with have pipes | . e.g. Mario:d=4,o=5,b=100:32p,16e6,16e6,16p,16e6,16p,16c6,16e6,16p,16g6,8p,16p,16g -DUSE_ESP8266_BACKPACK This enables communication with the ESP Backpack for over-the-air updates ( env:FrSky_TX_R9M_via_WiFi ) \ud83d\udda5\ufe0f and debugging via WebSocket \ud83d\udd0d. Uncommented by default, does not need to be changed.","title":"Other Options"},{"location":"software/user-defines/#obsolete-user_defines","text":"See Obsolete user_defines","title":"Obsolete user_defines"},{"location":"software/updating/betaflight-passthrough/","text":"Updating through BF Passthrough \u00b6 General Instructions \u00b6 Once you have Flashed ELRS onto your receivers they can be conveniently updating using the passthrough feature of Betaflight (and similar FC FW). This is a relatively simple process. Open VS Code or the configurator and prepare to compile and upload. Plug in your FC to your computer, but do NOT connect to betaflight configurator. Select env:YOUR_RX_via_Betaflight_Passthrough and hit upload. That's it! ESP-Specific Instructions \u00b6 Since 1.0.0, ESP receivers can be updated via passthrough without using the boot button as long as the firmware is not corrupted. If you're unable to get it to work, your firmware might be corrupted, in which case you'll need to temporarily turn off the telemetry feature in betaflight. If it still doesn't work, the bootloader might be messed up and the following steps should work. Open VS Code or the configurator and prepare to compile and upload. Plug in your FC to your computer, but do NOT connect to betaflight configurator and no NOT power the RX. If your RX gets powered from USB, desolder the power wire so that you can manually power it up independently of the flight controller. Hold the boot button of the RX or jump the boot jumper. Select env:YOUR_RX_via_Betaflight_Passthrough and hit upload. Wait for the command line to show .....----- . Plug in a battery or otherwise power up the RX. Troubleshooting \u00b6 If it fails to flash (may display a success message but has errors show up above the final success output), check if it is flashing the correct COM. Sometimes an ethernet adapter on your motherboard will populate a COM port, which will confuse the script and it will attempt to flash to that COM. The solution that could work would be manually editing the UARTUpload.py and BetaflightinitPassthrough.py files in src/python . Another possible solution could be changing the COM to a higher number for the unnecessary COMs Sometimes the boot jumper or button must be used while powering up the receiver. Ardupilot Instructions (community contribution, untested) \u00b6 Connect the autopilot to a PC using a USB cable and connect with a Ground Station (i.e. Mission Planner, QGC, etc). Set SERIAL_PASSTIMO to a length of time (in seconds) that gives you enough time to connect with the sensor\u2019s configuration software. 30 to 60 seconds is a good choice Set SERIAL_PASS2 to the number of the serial port connected to the sensor. I.e. \u201c2\u201d if the sensor is connected to Telem2/Serial2. Be sure to set each port\u2019s baud rate appropriately using the SERIALx_BAUD parameter. The rates may be different for each port. ArduPilot will do the buffering. Press the \u201cDisconnect\u201d button on the ground station but leave the USB cable from the PC to the autopilot connected. Open the sensor\u2019s configuration software and connect to the autopilot\u2019s COM port. If all goes well the configuration software should work as it does when the PC is directly connected to the sensor If the configuration fails to connect there are some things to try: Some configuration software will not allow connecting to the autopilot\u2019s COM port by default but may have a option to display all available COM ports If no serial messages are received from the PC the timeout will expire and SERIAL_PASS2 will revert to -1 https://ardupilot.org/.../common-serial-passthrough.html","title":"Betaflight Passthrough"},{"location":"software/updating/betaflight-passthrough/#updating-through-bf-passthrough","text":"","title":"Updating through BF Passthrough"},{"location":"software/updating/betaflight-passthrough/#general-instructions","text":"Once you have Flashed ELRS onto your receivers they can be conveniently updating using the passthrough feature of Betaflight (and similar FC FW). This is a relatively simple process. Open VS Code or the configurator and prepare to compile and upload. Plug in your FC to your computer, but do NOT connect to betaflight configurator. Select env:YOUR_RX_via_Betaflight_Passthrough and hit upload. That's it!","title":"General Instructions"},{"location":"software/updating/betaflight-passthrough/#esp-specific-instructions","text":"Since 1.0.0, ESP receivers can be updated via passthrough without using the boot button as long as the firmware is not corrupted. If you're unable to get it to work, your firmware might be corrupted, in which case you'll need to temporarily turn off the telemetry feature in betaflight. If it still doesn't work, the bootloader might be messed up and the following steps should work. Open VS Code or the configurator and prepare to compile and upload. Plug in your FC to your computer, but do NOT connect to betaflight configurator and no NOT power the RX. If your RX gets powered from USB, desolder the power wire so that you can manually power it up independently of the flight controller. Hold the boot button of the RX or jump the boot jumper. Select env:YOUR_RX_via_Betaflight_Passthrough and hit upload. Wait for the command line to show .....----- . Plug in a battery or otherwise power up the RX.","title":"ESP-Specific Instructions"},{"location":"software/updating/betaflight-passthrough/#troubleshooting","text":"If it fails to flash (may display a success message but has errors show up above the final success output), check if it is flashing the correct COM. Sometimes an ethernet adapter on your motherboard will populate a COM port, which will confuse the script and it will attempt to flash to that COM. The solution that could work would be manually editing the UARTUpload.py and BetaflightinitPassthrough.py files in src/python . Another possible solution could be changing the COM to a higher number for the unnecessary COMs Sometimes the boot jumper or button must be used while powering up the receiver.","title":"Troubleshooting"},{"location":"software/updating/betaflight-passthrough/#ardupilot-instructions-community-contribution-untested","text":"Connect the autopilot to a PC using a USB cable and connect with a Ground Station (i.e. Mission Planner, QGC, etc). Set SERIAL_PASSTIMO to a length of time (in seconds) that gives you enough time to connect with the sensor\u2019s configuration software. 30 to 60 seconds is a good choice Set SERIAL_PASS2 to the number of the serial port connected to the sensor. I.e. \u201c2\u201d if the sensor is connected to Telem2/Serial2. Be sure to set each port\u2019s baud rate appropriately using the SERIALx_BAUD parameter. The rates may be different for each port. ArduPilot will do the buffering. Press the \u201cDisconnect\u201d button on the ground station but leave the USB cable from the PC to the autopilot connected. Open the sensor\u2019s configuration software and connect to the autopilot\u2019s COM port. If all goes well the configuration software should work as it does when the PC is directly connected to the sensor If the configuration fails to connect there are some things to try: Some configuration software will not allow connecting to the autopilot\u2019s COM port by default but may have a option to display all available COM ports If no serial messages are received from the PC the timeout will expire and SERIAL_PASS2 will revert to -1 https://ardupilot.org/.../common-serial-passthrough.html","title":"Ardupilot Instructions (community contribution, untested)"},{"location":"software/updating/wifi-updating/","text":"Build your fimware and locate your firmware.bin file (this may be named something else if someone built it for you but that's fine) Put your device in Wi-Fi updating mode \ud83d\udcf6 a. For TX, open LUA script on the handset and select \"Wi-Fi Update\" b. For RX, power the receiver by plugging in a battery or USB and wait for LED to be blinking fast \ud83d\ude48 Connect to the Wi-Fi network from your computer with the password expresslrs Note 1: Some receivers have very weak Wi-Fi antennas so they will have to be extremely close to the computer's Wi-Fi antenna. Note 2: If a window pops up automatically when you connect to the Wi-Fi , close it and use a regular browser window instead. Open a browser tab and navigate to http://10.0.0.1 Click \"Choose File\" Select firmware.bin from your latest build(eg: ...ExpressLRS\\src.pio\\build\\[target]\\firmware.bin) Click \"Update\" Wait for the page to refresh and your URL bar to say 10.0.0.1/update (it'll look like the page is frozen for a bit) WAIT AT LEAST 10 SECONDS after the page refreshes indicating the upload is complete. It takes time for the firmware to flash after the upload, so do not pull the power until you see activity on the LED of the device or you will soft brick your device due to pulling power mid-flash. Done! You now have the latest version of ELRS on your hardware. Go Fly! \ud83d\ude81","title":"Wifi Updating"}]}